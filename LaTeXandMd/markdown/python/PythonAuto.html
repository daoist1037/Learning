<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>基础</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css"
    integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
  <link rel="stylesheet"
    href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
  <link rel="stylesheet"
    href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
  <link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet"
    type="text/css">
  <style>
    .task-list-item {
      list-style-type: none;
    }

    .task-list-item-checkbox {
      margin-left: -20px;
      vertical-align: middle;
    }
  </style>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
      font-size: 14px;
      line-height: 1.6;
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
</head>

<body class="vscode-light">
  <h1 id="基础">基础</h1>
  <h2 id="整型浮点型和字符串数据类型">整型、浮点型和字符串数据类型</h2>
  <h2 id="字符串连接和复制">字符串连接和复制</h2>
  <ul>
    <li>
      <pre><code class="language-python"><div><span class="hljs-string">'abc'</span> + <span class="hljs-string">'def'</span>
</div></code></pre>
    </li>
    <li>
      <pre><code class="language-python"><div><span class="hljs-string">'abc'</span> * <span class="hljs-number">5</span> <span class="hljs-comment">#字符串变为 abc 重复5次，必须为整型</span>
</div></code></pre>
    </li>
  </ul>
  <h2 id="变量命名规则">变量命名规则</h2>
  <ol>
    <li>只能是一个词。<br></li>
    <li>只能包含字母、数字和下划线。<br></li>
    <li>不能以数字开头。<br></li>
  </ol>
  <h2 id="print函数"><code>print()</code>函数</h2>
  <p>关键字：</p>
  <ul>
    <li><code>seq</code> 会指定<code>print()</code>内元素间隔用什么取代，默认是空格
      <pre><code class="language-python"><div>print(<span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>, seq=<span class="hljs-string">''</span>)
</div></code></pre>
    </li>
    <li><code>end</code> 会指定两个`print()'之间是否换行，默认是自动添加换行
      <pre><code class="language-python"><div>print(<span class="hljs-string">'hello'</span>,end=<span class="hljs-string">''</span>)
print(<span class="hljs-string">'world'</span>)
</div></code></pre>
    </li>
  </ul>
  <h2 id="input函数"><code>input()</code>函数</h2>
  <ul>
    <li>下例会在输入前输出 Your name is 作为提示，然后将输入赋给 name
      <pre><code class="language-python"><div>name = input(<span class="hljs-string">'Your name is: '</span>)
</div></code></pre>
    </li>
  </ul>
  <h2 id="len函数"><code>len()</code>函数</h2>
  <ul>
    <li>获取长度，如字符串长度，数组长度</li>
  </ul>
  <h2 id="str-float-int函数"><code>str() float() int()</code>函数</h2>
  <ul>
    <li>返回相应类型的数据</li>
  </ul>
  <h1 id="控制流">控制流</h1>
  <h2 id="布尔值">布尔值</h2>
  <ul>
    <li><code>True</code></li>
    <li><code>False</code></li>
    <li>首字母大写</li>
  </ul>
  <h2 id="比较操作符">比较操作符</h2>
  <h2 id="布尔操作符">布尔操作符</h2>
  <ul>
    <li>and</li>
    <li>not</li>
    <li>or</li>
  </ul>
  <h2 id="控制流语句">控制流语句</h2>
  <p>代码块规则：</p>
  <ol>
    <li>缩进增加时，代码块开始。</li>
    <li>代码块可以包含其他代码块。</li>
    <li>缩进减少为零，或减少为外面包围代码块的缩进，代码块就结束了。</li>
  </ol>
  <h3 id="if-else-elif"><code>if else elif</code></h3>
  <pre><code class="language-python"><div><span class="hljs-keyword">if</span> name == <span class="hljs-string">'Alice'</span>:
  print(<span class="hljs-string">'Hi, Alice.'</span>)
<span class="hljs-keyword">elif</span> age &lt; <span class="hljs-number">12</span>:
  print(<span class="hljs-string">'You are not Alice, kiddo.'</span>)
<span class="hljs-keyword">else</span>:
  print(<span class="hljs-string">'You are neither Alice nor a little kid.'</span>)
</div></code></pre>
  <h3 id="while"><code>while</code></h3>
  <pre><code class="language-python"><div>name = <span class="hljs-string">''</span>
<span class="hljs-keyword">while</span> name != <span class="hljs-string">'your name'</span>:
  print(<span class="hljs-string">'Please type your name.'</span>)
  name = input()
  print(<span class="hljs-string">'Thank you!'</span>)
</div></code></pre>
  <h3 id="break跳出该层循环"><code>break</code>跳出该层循环</h3>
  <h3 id="continue直接进行下次循环"><code>continue</code>直接进行下次循环</h3>
  <h3 id="for-循环和range函数"><code>for</code> 循环和<code>range()</code>函数</h3>
  <pre><code class="language-python"><div>name = <span class="hljs-string">''</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">7</span>):
  print(i)
</div></code></pre>
  <p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML">
          <semantics>
            <mrow>
              <mo stretchy="false">[</mo>
              <mn>0</mn>
              <mo separator="true">,</mo>
              <mn>7</mn>
              <mo stretchy="false">)</mo>
            </mrow>
            <annotation encoding="application/x-tex">[0,7)</annotation>
          </semantics>
        </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
            style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span
            class="mord">0</span><span class="mpunct">,</span><span class="mspace"
            style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span
            class="mclose">)</span></span></span></span></p>
  <h3 id="range的开始停止和步长参数"><code>range()</code>的开始、停止和步长参数</h3>
  <pre><code class="language-python"><div>range(<span class="hljs-number">12</span>,<span class="hljs-number">16</span>)  <span class="hljs-comment">#[12,16)</span>
range(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">#第三个元素为步长 0 2 4 6 8 </span>
</div></code></pre>
  <h3 id="导入模块">导入模块</h3>
  <p>import 语句包含以下部分：</p>
  <ul>
    <li>import 关键字；</li>
    <li>模块的名称；</li>
    <li>可选的更多模块名称，之间用逗号隔开。</li>
  </ul>
  <pre><code class="language-python"><div><span class="hljs-keyword">import</span> random
<span class="hljs-keyword">import</span> random, sys, os, math
<span class="hljs-comment"># 调用模块内函数时候</span>
random.randit(<span class="hljs-number">1</span>,<span class="hljs-number">7</span>)  <span class="hljs-comment">#必须以模块名.函数名的形式</span>
<span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> *  <span class="hljs-comment">#若以该形式导入模块就直接使用函数名调用</span>
</div></code></pre>
  <h3 id="用sysexit提前结束程序">用<code>sys.exit()</code>提前结束程序</h3>
  <h1 id="函数">函数</h1>
  <pre><code class="language-python"><div>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span><span class="hljs-params">(name)</span>:</span>
    print(<span class="hljs-string">'Hello '</span> + name)
    <span class="hljs-keyword">return</span> name
</div></code></pre>
  <h2 id="none-值"><code>None</code> 值</h2>
  <ul>
    <li><code>None</code> 是<code>NoneType</code> 数据类型的唯一值（其他编程语言可能称这个值为<code>null</code>、<code>nil</code>
      或<code>undefined</code>）。就像布尔值<code>True</code>和<code>False </code>一样，<code>None</code> 必须大写首字母<code>N</code>。
    </li>
  </ul>
  <h2 id="局部和全局作用域">局部和全局作用域</h2>
  <h2 id="名称相同的局部变量和全局变量">名称相同的局部变量和全局变量</h2>
  <pre><code class="language-python"><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spam</span><span class="hljs-params">()</span>:</span>
  eggs = <span class="hljs-string">'spam local'</span>
  print(eggs) <span class="hljs-comment"># prints 'spam local'</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bacon</span><span class="hljs-params">()</span>:</span>
  eggs = <span class="hljs-string">'bacon local'</span>
  print(eggs) <span class="hljs-comment"># prints 'bacon local'</span>
  spam()
  print(eggs) <span class="hljs-comment"># prints 'bacon local'</span>

eggs = <span class="hljs-string">'global'</span>
bacon()
print(eggs) <span class="hljs-comment"># prints 'global'</span>
</div></code></pre>
  <p>结果会是</p>
  <blockquote>
    <p>bacon local<br>
      spam local<br>
      bacon local<br>
      global<br>
      变量名相同时，会屏蔽全局变量</p>
  </blockquote>
  <h2 id="global-语句"><code>global</code> 语句</h2>
  <p>如果需要在一个函数内修改全局变量，就使用global 语句</p>
  <pre><code class="language-python"><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spam</span><span class="hljs-params">()</span>:</span>
  <span class="hljs-keyword">global</span> eggs
  eggs = <span class="hljs-string">'spam'</span>

eggs = <span class="hljs-string">'global'</span>
spam()
print(eggs)
</div></code></pre>
  <h2 id="异常梳理">异常梳理</h2>
  <p>如果在try 子句中的代码导致一个错误，程序执行就立即转到except 子句的代
    码。</p>
  <pre><code class="language-python"><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spam</span><span class="hljs-params">(divideBy)</span>:</span>
<span class="hljs-keyword">try</span>:
  <span class="hljs-keyword">return</span> <span class="hljs-number">42</span> / divideBy
<span class="hljs-keyword">except</span> ZeroDivisionError:
  print(<span class="hljs-string">'Error: Invalid argument.'</span>)
</div></code></pre>
  <h1 id="列表">列表</h1>
  <h2 id="列表数据类型">列表数据类型</h2>
  <ul>
    <li><code>['cat', 'bat', 'rat', 'elephant']</code></li>
    <li><code>[]</code>是一个空列表，不包含任何值，类似于空字符串</li>
  </ul>
  <h3 id="用下标取得列表中的单个值">用下标取得列表中的单个值</h3>
  <pre><code class="language-python"><div>spam = [<span class="hljs-string">'cat'</span>, <span class="hljs-string">'bat'</span>, <span class="hljs-string">'rat'</span>, <span class="hljs-string">'elephant'</span>]
spam[<span class="hljs-number">1</span>]

spam = [[<span class="hljs-string">'cat'</span>, <span class="hljs-string">'bat'</span>], [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>]]
spam[<span class="hljs-number">0</span>]
spam[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]
</div></code></pre>
  <h3 id="负数下标">负数下标</h3>
  <ul>
    <li>整数值−1 指的是列表中的最后一个下标</li>
    <li>−2 指的是列表中倒数第二个下标，以此类推</li>
  </ul>
  <h3 id="利用切片取得子列表">利用切片取得子列表</h3>
  <pre><code class="language-python"><div>spam[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>] <span class="hljs-comment">#左闭右开</span>
spam[:<span class="hljs-number">2</span>]
spam[:]
</div></code></pre>
  <h3 id="用下标改变列表中的值">用下标改变列表中的值</h3>
  <h3 id="列表连接和列表复制">列表连接和列表复制</h3>
  <pre><code class="language-python"><div>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] + [<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>]
[<span class="hljs-string">'X'</span>, <span class="hljs-string">'Y'</span>, <span class="hljs-string">'Z'</span>] * <span class="hljs-number">3</span>
</div></code></pre>
  <h3 id="用del-语句从列表中删除值">用<code>del </code>语句从列表中删除值</h3>
  <ul>
    <li><code>del</code> 语句将删除列表中下标处的值，表中被删除值后面的所有值，都将向前移
      动一个下标</li>
  </ul>
  <h2 id="列表用于循环">列表用于循环</h2>
  <h3 id="in-和not-in-操作符"><code>in</code> 和<code>not in</code> 操作符</h3>
  <pre><code class="language-python"><div><span class="hljs-string">'howdy'</span> <span class="hljs-keyword">in</span> [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'hi'</span>, <span class="hljs-string">'howdy'</span>, <span class="hljs-string">'heyas'</span>]
<span class="hljs-comment">#返回布尔值</span>
</div></code></pre>
  <h3 id="多重赋值技巧">多重赋值技巧</h3>
  <pre><code class="language-python"><div>cat = [<span class="hljs-string">'fat'</span>, <span class="hljs-string">'black'</span>, <span class="hljs-string">'loud'</span>]
size, color, disposition = cat
<span class="hljs-comment"># size color disposition 将依次被赋予与列表cat顺序相同的值</span>
</div></code></pre>
  <h2 id="增强的赋值操作">增强的赋值操作</h2>
  <pre><code class="language-python"><div>bacon *= <span class="hljs-number">3</span>
</div></code></pre>
  <h2 id="方法">方法</h2>
  <h3 id="用index方法在列表中查找值">用<code>index()</code>方法在列表中查找值</h3>
  <ul>
    <li>列表值有一个<code>index()</code>方法，可以传入一个值，如果该值存在于列表中，就返回它
      的下标。如果该值不在列表中，Python 就报 <strong>ValueError</strong></li>
    <li>如果列表中存在重复的值，就返回它第一次出现的下标</li>
  </ul>
  <pre><code class="language-python"><div>spam = [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'hi'</span>, <span class="hljs-string">'howdy'</span>, <span class="hljs-string">'heyas'</span>]
spam.index(<span class="hljs-string">'hello'</span>) <span class="hljs-comment">#返回下标0</span>
</div></code></pre>
  <h3 id="用append和insert方法在列表中添加值">用<code>append()</code>和<code>insert()</code>方法在列表中添加值</h3>
  <ul>
    <li><code>append()</code>方法调用，将参数添加到列表末尾</li>
    <li><code>insert()</code>方法可以在列表任意下标处插入一个值。<code>insert()</code>方法的第一个参数是新值的下标，第二个参数是要插入的新值</li>
    <li><code>append()</code>和<code>insert()</code>都不会将 列表 的新值作为其返回值（类似于void函数）</li>
  </ul>
  <h3 id="用remove方法从列表中删除值">用<code>remove()</code>方法从列表中删除值</h3>
  <ul>
    <li>给 <code>remove()</code>方法传入一个值，它将从被调用的列表中删除。
      <pre><code class="language-python"><div>spam = [<span class="hljs-string">'zophie'</span>,<span class="hljs-string">'fat'</span>,<span class="hljs-string">'yellow'</span>]
spam.remove(<span class="hljs-string">'fat'</span>)
</div></code></pre>
    </li>
    <li>如果该值在列表中出现多次，只有第一次出现的值会被删除</li>
  </ul>
  <h3 id="用sort方法将列表中的值排序">用<code>sort()</code>方法将列表中的值排序</h3>
  <ul>
    <li>数值的列表或字符串的列表，能用 <code>sort()</code>方法排序
      <pre><code class="language-python"><div>spam = [<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3.14</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-7</span>]
spam.sort()
</div></code></pre>
    </li>
    <li>数值按照大小</li>
    <li>对字符串排序时，使用“ASCII 字符顺序”，而不是实际的字典顺序；这意味着大写字母排在小写字母之前。因此在排序时，<strong>小写的a 在大写的Z 之后</strong></li>
    <li>如果需要按照普通的字典顺序来排序，就在sort()方法调用时，将关键字参数<code>key</code> 设置为<code>str.lower</code>
      <pre><code class="language-python"><div>spam = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'z'</span>, <span class="hljs-string">'A'</span>, <span class="hljs-string">'Z'</span>]
spam.sort(key=str.lower)
</div></code></pre>
    </li>
    <li>同样无返回值</li>
    <li>也可以指定<code>reverse </code>关键字参数为<code>True</code>，让<code>sort()</code>按逆序排序。
      <pre><code class="language-python"><div>spam.sort(reverse=<span class="hljs-literal">True</span>)
spam
</div></code></pre>
    </li>
  </ul>
  <h2 id="类似列表的类型字符串和元组">类似列表的类型：字符串和元组</h2>
  <h3 id="元组数据类型">元组数据类型</h3>
  <ul>
    <li>元组输入时用圆括号<code>()</code>，而不是用方括号[]</li>
    <li>元组<strong>不能</strong>让它们的值被修改、添加或删除。
      <code>spam=('cat','name','fat')</code></li>
    <li>如果元组中只有一个值，你可以在括号内该值的后面跟上一个逗号，表明这种情况。否则，Python 将认为，你只是在一个普通括号内输入了一个值。</li>
  </ul>
  <h3 id="用list和tuple函数来转换类型">用<code>list()</code>和<code>tuple()</code>函数来转换类型</h3>
  <pre><code class="language-python"><div>tuple([<span class="hljs-string">'cat'</span>, <span class="hljs-string">'dog'</span>, <span class="hljs-number">5</span>])
list((<span class="hljs-string">'cat'</span>, <span class="hljs-string">'dog'</span>, <span class="hljs-number">5</span>))
</div></code></pre>
  <h3 id="引用">引用</h3>
  <pre><code class="language-python"><div>spam = <span class="hljs-number">42</span>
cheese = spam
pam = <span class="hljs-number">100</span>
</div></code></pre>
  <p>spam和cheese
    是不同的变量，保存了不同的值，改变spam或者cheese不会影响另一个值</p>
  <p>但列表不是这样的。当你将列表赋给一个变量时，<strong>实际上是将列表的“引用”赋给了该变量</strong>。引用是一个值，指向某些数据。列表引用是指向一个列表的值</p>
  <pre><code class="language-python"><div>spam = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
cheese = spam
cheese[<span class="hljs-number">1</span>] = <span class="hljs-string">'Hello!'</span>
</div></code></pre>
  <p>代码只改变了cheese 列表，但似乎cheese 和spam 列表同时发生了改变</p>
  <h3 id="copy-模块的copy和deepcopy函数"><code>copy</code> 模块的<code>copy()</code>和<code>deepcopy()</code>函数</h3>
  <ul>
    <li><code>copy.copy()</code>可以用来复制列表或字典这样的可变值，而不只是复制引用
      <pre><code class="language-python"><div><span class="hljs-keyword">import</span> copy
spam = [<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>]
cheese = copy.copy(spam)
cheese[<span class="hljs-number">1</span>] = <span class="hljs-number">42</span>
</div></code></pre>
    </li>
    <li><code>deepcopy()</code>函数将同时复制它们内部的列表</li>
  </ul>
  <h1 id="字典和结构化数据">字典和结构化数据</h1>
  <h2 id="字典数据类型">字典数据类型</h2>
  <ul>
    <li>字典的索引可以使用许多不同数据类型，不只是整数。字典的索引被称为“键”，键及其关联的值
      称为“键-值”对。</li>
  </ul>
  <pre><code class="language-python"><div>myCat = {<span class="hljs-string">'size'</span>: <span class="hljs-string">'fat'</span>, <span class="hljs-string">'color'</span>: <span class="hljs-string">'gray'</span>, <span class="hljs-string">'disposition'</span>: <span class="hljs-string">'loud'</span>}
myCat[<span class="hljs-string">'size'</span>]
</div></code></pre>
  <ul>
    <li>不像列表，字典中的表项是不排序的,键-值对输入的顺序并不重要</li>
    <li>因为字典是不排序的，所以不能像列表那样切片</li>
  </ul>
  <h2 id="keysvalues和items方法"><code>keys()</code>、<code>values()</code>和<code>items()</code>方法</h2>
  <ul>
    <li>有3 个字典方法，它们将返回类似列表的值，分别对应于字典的键、值和键-值对：<code>keys()、values()和items()</code>。</li>
    <li>这些方法返回的值不是真正的列表，它们不能被修改，没有append()方法。但这些数据类型（分别是<code>dict_keys、dict_values 和dict_items</code>）可以用于for 循环。</li>
  </ul>
  <h2 id="get方法"><code>get()</code>方法</h2>
  <ul>
    <li>，它有两个参数：要取得其值的键，以及如果该键不存在时，返回的备用值。</li>
    <li>不使用get()，当访问一个不存在的键-值，代码就会产生一个错误消息</li>
    <li><code>dict.get(key,value)</code></li>
  </ul>
  <h2 id="setdefault方法"><code>setdefault()</code>方法</h2>
  <ul>
    <li>传递给该方法的第一个参数，是要检查的键。第二个参数，是如果该键不存在时要设置的值。如果该键确实存在，方法就会返回键的值</li>
    <li>
      与<code>get()</code>区别是：<code>get</code>只是返回值，并不更改/添加键-值，<code>setdefault</code>则是设置默认值（如果不存在）并返回<code>value</code>，若存在则返回<code>value</code>
    </li>
  </ul>
  <h2 id="漂亮打印">漂亮打印</h2>
  <ul>
    <li>导入<code>pprint</code> 模块，就可以使用<code>pprint()</code>和<code>pformat()</code>函数</li>
    <li>使用<code>pprint</code>输出字典等，输出的字典是有序的，但不影响原本字典的内容</li>
    <li>以下两行代码等价
      <pre><code class="language-python"><div>pprint.pprint(someDictionaryValue)
print(pprint.pformat(someDictionaryValue))
</div></code></pre>
    </li>
  </ul>
  <h1 id="字符串操作">字符串操作</h1>
  <h2 id="处理字符串">处理字符串</h2>
  <h3 id="字符串可以用双引号开始和结束就像用单引号一样使用双引号的一个好处就是字符串中可以使用单引号字符">字符串可以用双引号开始和结束，就像用单引号一样。使用双引号的一个好处，就是字符串中可以使用单引号字符</h3>
  <h3 id="转义字符">转义字符</h3>
  <h3 id="原始字符串">原始字符串</h3>
  <ul>
    <li>在字符串开始的引号之前加上r，使它成为原始字符串。“原始字符串”完全忽略所有的转义字符，打印出字符串中所有的倒斜杠</li>
  </ul>
  <h3 id="用三重引号的多行字符串">用三重引号的多行字符串</h3>
  <ul>
    <li>在Python 中，多行字符串的起止是3 个单引号或3 个双引号。“三重引号”之间的所有<strong>引号、制表符或换行</strong>，都被认为是字符串的一部分。Python 的代码块缩进规则不适用于多行字符串
    </li>
  </ul>
  <h3 id="多行注释">多行注释</h3>
  <ul>
    <li>单行注释 #</li>
    <li>多行注释 如同多行字符串 三重引号之间就是注释的内容</li>
  </ul>
  <h3 id="字符串下标和切片">字符串下标和切片</h3>
  <ul>
    <li>左闭右开</li>
  </ul>
  <h2 id="有用的字符串方法">有用的字符串方法</h2>
  <h3 id="字符串方法upperlowerisupper和islower">
    字符串方法<code>upper()</code>、<code>lower()</code>、<code>isupper()</code>和<code>islower()</code></h3>
  <ul>
    <li>
      <code>upper()</code>和<code>lower()</code>字符串方法返回一个新字符串，其中原字符串的所有字母都被相应地<strong>转换为大写或小写</strong>。字符串中<strong>非字母字符保持不变</strong>。
      <ul>
        <li><strong>这些方法没有改变字符串本身，而是返回一个新字符串</strong></li>
      </ul>
    </li>
    <li>
      如果字符串至少有一个字母，并且所有字母都是大写或小写，<code>isupper()</code>和<code>islower()</code>方法就会相应地返回布尔值<code>True</code>。否则，该方法返回<code>False</code>
    </li>
    <li>因为<code>upper()</code>和<code>lower()</code>字符串方法本身返回字符串，所以也可以在“那些”返回的字符串上继续调用字符串方法。这样做的表达式看起来就像方法调用链</li>
    <li><code>isX</code> 字符串方法<br>
      还有几个字符串方法，它们的名字以 is 开始。这些方法返回一个布尔值，描述了字符串的特点
      <ul>
        <li><code>isalpha()</code>返回<code>True</code>，如果字符串只包含字母，并且非空；</li>
        <li><code>isalnum()</code>返回<code>True</code>，如果字符串只包含字母和数字，并且非空；</li>
        <li><code>isdecimal()</code>返回<code>True</code>，如果字符串只包含数字字符，并且非空；</li>
        <li><code>isspace()</code>返回<code>True</code>，如果字符串只包含空格、制表符和换行，并且非空；</li>
        <li><code>istitle()</code>返回<code>True</code>，如果字符串仅包含以大写字母开头、后面都是小写字母的单词</li>
      </ul>
    </li>
  </ul>
  <h3 id="字符串方法startswith和endswith">字符串方法<code>startswith()</code>和<code>endswith()</code></h3>
  <ul>
    <li>
      <code>startswith()</code>和<code>endswith()</code>方法返回<code>True</code>，如果它们所调用的字符串以该方法传入的字符串开始或结束。否则，方法返回<code>False</code>
    </li>
  </ul>
  <h3 id="字符串方法join和split">字符串方法<code>join()</code>和<code>split()</code></h3>
  <ul>
    <li><code>join()</code>方法在一个字符串上调用，参数是一个字符串列表，返回一个字符串。返回的字符串由传入的列表中每个字符串连接而成
      <pre><code class="language-python"><div><span class="hljs-string">', '</span>.join([<span class="hljs-string">'cats'</span>, <span class="hljs-string">'rats'</span>, <span class="hljs-string">'bats'</span>]) <span class="hljs-comment">#返回字符串</span>
</div></code></pre>
    </li>
    <li><code>split()</code>方法做的事情正好相反：它针对一个字符串调用，返回一个字符串列表
      <pre><code class="language-python"><div><span class="hljs-string">'My name is Simon'</span>.split()
<span class="hljs-comment"># 返回字符串列表，分割依据是单词间的空格</span>
</div></code></pre>
    </li>
  </ul>
  <h3 id="用rjustljust和center方法对齐文本">用<code>rjust()</code>、<code>ljust()</code>和<code>center()</code>方法对齐文本</h3>
  <ul>
    <li><code>rjust()</code>和<code>ljust()</code>字符串方法<strong>返回调用它们的字符串的填充版本</strong>，通过插入空格（默认情况下）来对齐文本。</li>
    <li>这两个方法的第一个参数是一个整数长度，用于对齐字符串</li>
    <li>第二个可选参数将指定一个填充字符，取代空格字符</li>
    <li><code>center()</code>字符串方法与<code>ljust()</code>与<code>rjust()</code>类似，但它让文本居中，而不是左对齐或右对齐</li>
  </ul>
  <h3 id="用triprstrip和lstrip删除空白字符">用<code>trip()</code>、<code>rstrip()</code>和<code>lstrip()</code>删除空白字符</h3>
  <ul>
    <li><code>strip()</code>字符串方法将<strong>返回一个新的字符串</strong>，它的开头或末尾都没有空白字符。</li>
    <li><code>lstrip()</code>和<code>rstrip()</code>方法将相应删除左边或右边的空白字符</li>
    <li>有一个可选的字符串参数，指定两边的哪些字符应该删除
      <ul>
        <li>传入<code>strip()</code>方法的字符串中，<strong>字符的顺序并不重要</strong>
          ``python
          spam = 'SpamSpamBaconSpamEggsSpamSpam'
          spam.strip('ampS')</li>
      </ul>
      <pre><code><code><div></div></code></code></pre>
    </li>
  </ul>
  <h2 id="用pyperclip-模块拷贝粘贴字符串">用pyperclip 模块拷贝粘贴字符串</h2>
  <ul>
    <li><code>pyperclip</code>模块有<code>copy()</code>和<code>paste()</code>函数，可以向计算机的剪贴板发送文本，或从它接收文本</li>
  </ul>
  <h2 id="处理命令行参数">处理命令行参数</h2>
  <ul>
    <li>命令行参数将存储在变量sys.argv 中
      <ul>
        <li>python <a href="http://pw.py">pw.py</a> name 那么sys.argv[0] = '<a
            href="http://pw.py">pw.py</a>'，sys.argv[1]='name'</li>
      </ul>
    </li>
  </ul>
  <h1 id="模式匹配与正则表达式">模式匹配与正则表达式</h1>
  <h2 id="用正则表达式查找文本模式">用正则表达式查找文本模式</h2>
  <h3 id="创建正则表达式对象">创建正则表达式对象</h3>
  <pre><code class="language-python"><div><span class="hljs-keyword">import</span> re
phoneNumRegex = re.compile(<span class="hljs-string">r'\d\d\d-\d\d\d-\d\d\d\d'</span>)
</div></code></pre>
  <ul>
    <li>向<code>re.compile()</code>传入一个字符串值，表示正则表达式，它将返回一个<code>Regex</code> 模式对象（或者就简称为Regex 对象</li>
  </ul>
  <h3 id="匹配regex-对象">匹配<code>Regex</code> 对象</h3>
  <ul>
    <li><code>Regex</code>
      对象的<code>search()</code>方法查找传入的字符串，寻找该正则表达式的所有匹配。如果字符串中没有找到该正则表达式模式，<code>search()</code>方法将返回<code>None</code>。如果找到了该模式，<code>search()</code>方法将返回一个<code>Match</code>
      对象</li>
    <li><code>Match</code> 对象有一个<code>group()</code>方法，它返回被查找字符串中实际匹配的文本
      <pre><code class="language-python"><div>phoneNumRegex = re.compile(<span class="hljs-string">r'\d\d\d-\d\d\d-\d\d\d\d'</span>)
mo = phoneNumRegex.search(<span class="hljs-string">'My number is 415-555-4242.'</span>)
print(<span class="hljs-string">'Phone number found: '</span> + mo.group())
</div></code></pre>
    </li>
    <li><code>group()</code>返回匹配到的内容</li>
    <li><code>group(0)</code>返回匹配到的内容</li>
    <li><code>group(1)</code>返回正则表达式中第一个括号内的内容，第一组</li>
  </ul>
  <h2 id="用正则表达式匹配更多模式">用正则表达式匹配更多模式</h2>
  <h3 id="利用括号分组">利用括号分组</h3>
  <ul>
    <li>向<code>group()</code>匹配对象方法传入整数 1 或 2 ，就可以取得匹配文本的不同部分。</li>
    <li>向<code>group()</code>方法传入 0 或不传入参数，将返回整个匹配的文本</li>
    <li>如果想要一次就获取所有的分组，使用<code>groups()</code>方法，返回多个值的<strong>元组</strong></li>
  </ul>
  <h3 id="用管道匹配多个分组">用管道匹配多个分组</h3>
  <ul>
    <li>字符 <code>|</code> 称为“管道”。希望匹配许多表达式中的一个时，就可以使用它</li>
    <li>第一次出现的匹配文本，将作为<code>Match</code> 对象返回。</li>
  </ul>
  <h3 id="用问号实现可选匹配">用问号实现可选匹配</h3>
  <pre><code class="language-python"><div>batRegex = re.compile(<span class="hljs-string">r'Bat(wo)?man'</span>)
</div></code></pre>
  <p>正则表达式中的<code>(wo)?</code>部分表明，模式 <code>wo</code> 是可选的分组。该正则表达式匹配的文本中，<code>wo</code> 将出现<strong>零次或一次</strong></p>
  <h3 id="用星号匹配零次或多次">用星号匹配零次或多次</h3>
  <ul>
    <li>*（称为星号）意味着“匹配零次或多次”，即星号之前的分组，可以在文本中出现任意次。它可以完全不存在，或一次又一次地重复</li>
  </ul>
  <h3 id="用加号匹配一次或多次">用加号匹配一次或多次</h3>
  <ul>
    <li>加号前面的分组必须“至少出现一次”</li>
  </ul>
  <h3 id="用花括号匹配特定次数">用花括号匹配特定次数</h3>
  <ul>
    <li>
      如果想要一个分组重复特定次数，就在正则表达式中该分组的后面，跟上花括号包围的数字。例如，正则表达式<code>(Ha){3}</code>将匹配字符串<code>'HaHaHa'</code>，但不会匹配<code>'HaHa'</code>
    </li>
    <li>
      除了一个数字，还可以<strong>指定一个范围</strong>，即在花括号中写下一个最小值、一个逗号和一个最大值。例如，正则表达式<code>(Ha){3,5}</code>将匹配<code>'HaHaHa'</code>、<code>'HaHaHaHa'</code>和<code>'HaHaHaHaHa'</code>
    </li>
    <li>也可以不写花括号中的第一个或第二个数字，不限定最小值或最大值（类似于分片)
      比如<code>(Ha){3,}</code>将匹配3次或更多次</li>
  </ul>
  <h2 id="贪心和非贪心匹配">贪心和非贪心匹配</h2>
  <ul>
    <li>Python
      的正则表达式默认是“贪心”的，这表示在有二义的情况下，它们会尽可能匹配最长的字符串。比如<code>(Ha){3,5}</code>遇到<code>'HaHaHaHaHa'</code>会返回<code>'HaHaHaHaHa'</code>即是匹配最长字符
    </li>
    <li>花括号的“非贪心”版本匹配尽可能最短的字符串，即在结束的花括号后跟着一个问号。
      比如<code>(Ha){3,5}?</code>遇到<code>'HaHaHaHaHa'</code>会返回<code>'HaHaHa'</code></li>
  </ul>
  <h2 id="findall方法">findall()方法</h2>
  <ul>
    <li><code>findall()</code>方法将返回一组字符串，包含被查找字符串中的所有匹配</li>
    <li><code>findall()</code>不是返回一个<code>Match</code> 对象，而是返回<strong>一个字符串列表</strong>，只要在正则表达式中没有分组。</li>
    <li>如果在正则表达式中有分组，那么<code>findall</code> 将返回<strong>元组的列表</strong>。每个元组表示一个找到的匹配，其中的项就是正则表达式中每个分组的匹配字符串</li>
  </ul>
  <h2 id="字符分类">字符分类</h2>
  <ul>
    <li>\d 0 到9 的任何数字</li>
    <li>\D 除0 到9 的数字以外的任何字符</li>
    <li>\w 任何字母、数字或下划线字符（可以认为是匹配“单词”字符）</li>
    <li>\W 除字母、数字和下划线以外的任何字符</li>
    <li>\s 空格、制表符或换行符（可以认为是匹配“空白”字符）</li>
    <li>\S 除空格、制表符和换行符以外的任何字符</li>
  </ul>
  <h2 id="建立自己的字符分类">建立自己的字符分类</h2>
  <ul>
    <li>用方括号定义自己的字符分类</li>
    <li>使用短横表示字母或数字的范围</li>
    <li>在方括号内，普通的正则表达式符号不会被解释。这意味着，你不需要前面加上倒斜杠转义<code>.、*、?</code>或<code>()</code>字符</li>
    <li>通过在字符分类的左方括号后加上一个插入字符<code>^</code>，就可以得到“非字符类。非字符类将匹配不在这个字符类中的所有字符
      <code>^[ABSGHDH]</code></li>
  </ul>
  <h2 id="插入字符和美元字符">插入字符和美元字符</h2>
  <ul>
    <li>在正则表达式的开始处使用插入符号<code>^</code>，表明匹配必须发生在被查找文本开始处</li>
    <li>正则表达式的末尾加上美元符号<code>$</code>，表示该字符串必须以这个正则表达式的模式结束</li>
  </ul>
  <h2 id="通配字符">通配字符</h2>
  <ul>
    <li><code>.</code> （句点）字符称为“通配符”。它匹配<strong>除</strong>了换行之外的所有字符。</li>
  </ul>
  <h3 id="用点-星匹配所有字符">用点-星匹配所有字符</h3>
  <h3 id="用句点字符匹配换行">用句点字符匹配换行</h3>
  <ul>
    <li>通过传入<code>re.DOTALL</code> 作为<code>re.compile()</code>的第二个参数，可以让句点字符匹配所有字符，包括换行字符。</li>
  </ul>
  <h2 id="不区分大小写的匹配">不区分大小写的匹配</h2>
  <ul>
    <li>。要让正则表达式不区分大小写，可以向<code>re.compile()</code>传入<code>re.IGNORECASE</code> 或<code>re.I</code>，作为第二个参数。</li>
  </ul>
  <h2 id="用sub方法替换字符串">用<code>sub()</code>方法替换字符串</h2>
  <ul>
    <li>
      <code>Regex</code>对象的<code>sub()</code>方法需要传入两个参数。第一个参数是一个字符串，用于取代发现的匹配。第二个参数是一个字符串，即正则表达式。<code>sub()</code>方法<strong>返回替换完成后的字符串</strong>。
    </li>
  </ul>
  <h2 id="管理复杂的正则表达式">管理复杂的正则表达式</h2>
  <p>
    如果要匹配的文本模式很简单，正则表达式就很好。但匹配复杂的文本模式，可能需要长的、费解的正则表达式。你可以告诉<code>re.compile()</code>，忽略正则表达式字符串中的空白符和注释，从而缓解这一点。要实现这种详细模式，可以向<code>re.compile()</code>传入变量<code>re.VERBOSE</code>，作为第二个参数。
  </p>
  <pre><code class="language-python"><div>phoneRegex = re.compile(<span class="hljs-string">r'((\d{3}|\(\d{3}\))?(\s|-|\.)?\d{3}(\s|-|\.)\d{4}(\s*(ext|x|ext.)\s*\d{2,5})?)'</span>)
</div></code></pre>
  <p><strong>可以将正则表达式放在多行中，并加上注释</strong></p>
  <pre><code class="language-python"><div>phoneRegex = re.compile(<span class="hljs-string">r'''(
  (\d{3}|\(\d{3}\))? # area code
  (\s|-|\.)? # separator
  \d{3} # first 3 digits
  (\s|-|\.) # separator
  \d{4} # last 4 digits
  (\s*(ext|x|ext.)\s*\d{2,5})? # extension
  )'''</span>, re.VERBOSE)
</div></code></pre>
  <h2 id="组合使用reignorecaseredotall-和reverbose">组合使用<code>re.IGNORECASE、re.DOTALL </code>和<code>re.VERBOSE</code></h2>
  <ul>
    <li><code>re.compile()</code>函数只接受一个值作为它的第二参数</li>
    <li>可以使用管道字符<code>（|）</code>将变量组合起来，从而绕过这个限制。管道字符在这里称为“按位或”操作符。</li>
  </ul>
  <h1 id="读写文件">读写文件</h1>
  <h2 id="文件与文件路径">文件与文件路径</h2>
  <h3 id="windows-上的倒斜杠以及os-x-和linux-上的正斜杠"><code>Windows</code> 上的倒斜杠以及<code>OS X</code> 和<code>Linux</code> 上的正斜杠</h3>
  <ul>
    <li>在<code>Windows</code> 上，路径书写使用<strong>倒斜杠</strong>作为文件夹之间的分隔符。</li>
    <li>在<code>OS X 和</code>Linux` 上，使用<strong>正斜杠</strong>作为它们的路径分隔符。</li>
  </ul>
  <h4 id="ospathjoin"><code>os.path.join()</code></h4>
  <ul>
    <li>。如果将单个文件和路径上的文件夹名称的字符串传递给它，<code>os.path.join()</code>就会返回一个文件路径的字符串，包含正确的路径分隔符</li>
  </ul>
  <pre><code class="language-python"><div><span class="hljs-keyword">import</span> os
os.path.join(<span class="hljs-string">'usr'</span>, <span class="hljs-string">'bin'</span>, <span class="hljs-string">'spam'</span>)
<span class="hljs-comment">## 结果是'usr\\bin\\spam'</span>
</div></code></pre>
  <h3 id="当前工作目录">当前工作目录</h3>
  <h4 id="osgetcwd-和-oschdir"><code>os.getcwd()</code> 和 <code>os.chdir()</code></h4>
  <p>可以取得当前工作路径的字符串，并可以利用<code>os.chdir()</code>改变它</p>
  <h3 id="绝对路径与相对路径">绝对路径与相对路径</h3>
  <h3 id="用osmakedirs创建新文件夹">用<code>os.makedirs()</code>创建新文件夹</h3>
  <p>将创建所有必要的中间文件夹，目的是确保完整路径名存在</p>
  <h3 id="ospath-模块"><code>os.path</code> 模块</h3>
  <ul>
    <li>导入 <code>import os</code>（<code>os.path</code> 是<code>os</code> 模块中的模块，）</li>
  </ul>
  <h3 id="处理绝对路径和相对路径">处理绝对路径和相对路径</h3>
  <p><code>os.path</code> 模块提供了一些函数，返回一个相对路径的绝对路径，以及检查给定的路径是否为绝对路径。</p>
  <ul>
    <li>调用 <code>os.path.abspath(path)</code>将返回参数的绝对路径的字符串。这是将相对路径转换为绝对路径的简便方法。</li>
    <li>调用 <code>os.path.relpath(path, start)</code>将返回从<code>start</code> 路径到<code>path</code>
      的相对路径的字符串。如果没有提供<code>start</code>，就使用当前工作目录作为开始路径。</li>
    <li>调用 <code>os.path.isabs(path)</code>，如果参数是一个绝对路径，就返回<code>True</code>，如果参数是一个相对路径，就返回<code>False</code>。</li>
    <li><strong>基本名称</strong>跟在路径中最后一个斜杠后，它和文件名一样</li>
    <li><strong>目录名称</strong>是最后一个斜杠之前的所有内容</li>
    <li>调用 <code>os.path.dirname(path)</code>将返回一个字符串，它包含<code>path</code> 参数中最后一个斜杠之前的所有内容。</li>
    <li>调用<code>os.path.basename(path)</code>将返回一个字符串，它包含<code>path</code> 参数中最后一个斜杠之后的所有内容。</li>
    <li>如果同时需要一个路径的目录名称和基本名称，就可以调用<code>os.path.split()</code>，获得这两个字符串的元组</li>
    <li>
      <code>os.path.split()</code>不会接受一个文件路径并返回每个文件夹的字符串的列表。如果需要这样，请使用<code>split()</code>字符串方法，并根据<code>os.path.sep</code>
      中的字符串进行分割
      <ul>
        <li><code>split()</code>字符串方法将返回一个<strong>列表</strong>，包含该路径的所有部分。如果向它传递<code>os.path.sep</code>，就能在所有操作系统上工作。
        </li>
      </ul>
      <pre><code class="language-python"><div>calcFilePath = <span class="hljs-string">'C:\\Windows\\System32\\calc.exe'</span>
calcFilePath.split(os.path.sep)
<span class="hljs-comment"># 默认情况下 os.path.seq 会自动根据PC来适应</span>
</div></code></pre>
    </li>
  </ul>
  <h3 id="查看文件大小和文件夹内容">查看文件大小和文件夹内容</h3>
  <p><code>os.path</code> 模块提供了一些函数，用于查看文件的字节数以及给定文件夹中的文件和子文件夹。</p>
  <ul>
    <li>调用 <code>os.path.getsize(path)</code>将返回<code>path</code> 参数中文件的字节数</li>
    <li>调用 <code>os.listdir(path)</code>将返回文件名字符串的<strong>列表</strong>，包含<code>path</code>
      参数中的每个文件（请注意，这个函数在<code>os</code> 模块中，而不是<code>os.path</code>）</li>
    <li>调用<code>os.walk()</code>函数列出文件夹以及子文件夹中的每个文件</li>
  </ul>
  <h3 id="检查路径有效性">检查路径有效性</h3>
  <ul>
    <li>如果 <code>path</code>
      参数所指的文件或文件夹存在，调用<code>os.path.exists(path)</code>将返回<code>True</code>，否则返回<code>False</code>。</li>
    <li>如果 <code>path</code>
      参数存在，并且是一个文件，调用<code>os.path.isfile(path)</code>将返回<code>True</code>，否则返回<code>False</code>。</li>
    <li>如果 <code>path</code>
      参数存在，并且是一个文件夹，调用<code>os.path.isdir(path)</code>将返回<code>True</code>，否则返回<code>False</code>。</li>
  </ul>
  <h2 id="文件读写过程">文件读写过程</h2>
  <ul>
    <li>
      <ol>
        <li>调用open()函数，返回一个File 对象。</li>
        <li>调用File 对象的read()或write()方法。</li>
        <li>调用File 对象的close()方法，关闭该文件。
          或者</li>
      </ol>
    </li>
    <li>
      <pre><code class="language-python"><div><span class="hljs-keyword">with</span> open(path) <span class="hljs-keyword">as</span> name:
  <span class="hljs-comment"># 各种文件对象的操作代码</span>
</div></code></pre>
      等价于
      <pre><code class="language-python"><div>file = open(path)
<span class="hljs-comment"># 各种文件对象的操作代码</span>
file.close()
</div></code></pre>
    </li>
  </ul>
  <h3 id="用open函数打开文件">用<code>open()</code>函数打开文件</h3>
  <p>传递的字符串路径可以是绝对路径，也可以是相对路径。<code>open()</code>函数返回一个<code>File</code> 对象。</p>
  <ul>
    <li>默认是只读的形式打开</li>
    <li>要进行写入操作，传入第二个参数'w'等</li>
  </ul>
  <h3 id="读取文件内容">读取文件内容</h3>
  <ul>
    <li><code>helloContent = helloFile.read()</code>将整个文件的内容读取为<strong>一个字符串</strong>值</li>
    <li>使用<code>readlines()</code>方法，从该文件取得一个字符串的列表。列表中的每个字符串就是文本中的每一行</li>
  </ul>
  <h3 id="写入文件">写入文件</h3>
  <p>要以“<strong>写入纯文本模式</strong>”或“<strong>添加纯文本模式</strong>”打开该文件，或简称为“写模式”和“添加模式”。</p>
  <ul>
    <li>写模式将覆写原有的文件，从头开始;将<code>'w'</code>作为第二个参数传递给<code>open()</code></li>
    <li>将<code>'a'</code>作为第二个参数传递给<code>open()</code>，以添加模式打开该文件</li>
    <li>如果传递给<code>open()</code>的文件名不存在，写模式和添加模式都会创建一个新的空文件。在读取或写入文件后，调用<code>close()</code>方法，然后才能再次打开该文件。</li>
  </ul>
  <h2 id="用shelve-模块保存变量">用<code>shelve</code> 模块保存变量</h2>
  <ul>
    <li>利用<code>shelve</code> 模块，你可以将Python 程序中的变量保存到二进制的<code>shelf</code> 文件中。</li>
  </ul>
  <pre><code class="language-python"><div><span class="hljs-keyword">import</span> shelve
shelfFile = shelve.open(<span class="hljs-string">'mydata'</span>)
cats = [<span class="hljs-string">'Zophie'</span>, <span class="hljs-string">'Pooka'</span>, <span class="hljs-string">'Simon'</span>]
shelfFile[<span class="hljs-string">'cats'</span>] = cats
shelfFile.close()
</div></code></pre>
  <ul>
    <li>就像字典一样，<code>shelf</code> 值有<code>keys()</code>和<code>values()</code>方法，返回<code>shelf</code>
      中键和值的类似列表的值。因为这些方法返回类似列表的值，而<strong>不是真正的列表</strong>，所以应该将它们传递给<code>list()</code>函数，取得列表的形式</li>
  </ul>
  <h2 id="用pprintpformat函数保存变量">用<code>pprint.pformat()</code>函数保存变量</h2>
  <h1 id="组织文件">组织文件</h1>
  <h2 id="shutil模块"><code>shutil</code>模块</h2>
  <h3 id="复制文件和文件夹">复制文件和文件夹</h3>
  <h4 id="shutilcopysourcedestination-复制文件"><code>shutil.copy(source,destination)</code> 复制文件</h4>
  <ul>
    <li>调用<code>shutil.copy(source, destination)</code>，将路径<code>source</code>
      处的文件复制到路径<code>destination</code>处的文件夹（<code>source</code> 和<code>destination</code> 都是字符串）。</li>
    <li>如果<code>destination</code> 是一个文件名，它将作为被复制文件的新名字。</li>
    <li>该函数返回一个字符串，表示被复制文件的路径</li>
  </ul>
  <h4 id="shutilcopytreesourcedestination-复制文件夹"><code>shutil.copytree(source,destination)</code> 复制文件夹</h4>
  <ul>
    <li>调用<code>shutil.copytree(source, destination)</code>，将路径<code>source</code>
      处的文件夹，包括它的所有文件和子文件夹，复制到路径<code>destination</code> 处的文件夹。</li>
    <li><code>source</code> 和<code>destination</code> 参数都是字符串。</li>
    <li>该函数返回一个字符串，是新复制的文件夹的路径</li>
  </ul>
  <h3 id="文件和文件夹的移动与改名">文件和文件夹的移动与改名</h3>
  <ul>
    <li>调用<code>shutil.move(source, destination)</code>，将路径<code>source</code>
      处的文件夹移动到路径<code>destination</code>，并返回新位置的绝对路径的字符串。</li>
    <li>如果 <code>destination</code> 指向一个文件夹，<code>source</code> 文件将移动到<code>destination</code> 中，并保持原来的文件名</li>
    <li>如果已经存在一个文件，它就会被覆写</li>
  </ul>
  <h3 id="永久删除文件和文件夹">永久删除文件和文件夹</h3>
  <ul>
    <li>用 <code>os.unlink(path)</code>将删除<code>path</code> 处的文件。</li>
    <li>调用 <code>os.rmdir(path)</code>将删除<code>path</code> 处的文件夹。<strong>该文件夹必须为空</strong>，其中没有任何文件和文件夹。</li>
    <li>调用 <code>shutil.rmtree(path)</code>将删除<code>path</code> 处的文件夹，它包含的所有文件和文件夹都会被删除。</li>
  </ul>
  <h3 id="用send2trash-模块安全地删除可以在回收站找到">用<code>send2trash</code> 模块安全地删除，可以在回收站找到</h3>
  <ul>
    <li><code>send2trash(path)</code></li>
  </ul>
  <h2 id="用zipfile-模块压缩文件">用<code>zipfile</code> 模块压缩文件</h2>
  <h3 id="读取zip文件">读取<code>ZIP</code>文件</h3>
  <pre><code class="language-python"><div><span class="hljs-keyword">import</span> zipfile
wxampleZip = zipfile.ZipFile(path)
exampleZip.namelist()

spamInfo = exampletZip.getinfo(file)
spamInfo.file_size
spamInfo.compress_size
</div></code></pre>
  <ul>
    <li><code>namelist()</code>方法返回<code>ZIP</code>文件中包含的所有文件和文件夹的字符串的列表</li>
    <li>这些字符串可以传递给<code>ZipFile</code> 对象的<code>getinfo()</code>方法，返回一个关于特定文件的<code>ZipInfo</code>
      对象。<code>ZipInfo</code> 对象有自己的属性，诸如表示字节数的<code>file_size</code>和<code>compress_size</code>，它们分别表示原来文件大小和压缩后文件大小
    </li>
    <li><code>ZipFile</code> 对象表示整个归档文件，而<code>ZipInfo</code> 对象则保存该归档文件中每个文件的有用信息</li>
  </ul>
  <h3 id="解压缩">解压缩</h3>
  <ul>
    <li><code>ZipFile</code>对象的<code>extractall()</code>方法</li>
  </ul>
  <pre><code class="language-pthon"><code><div>exampleZip.extractall()
# 解压到工作目录
exampleZip.extractall(path)
# 解压到指定目录下
</div></code></code></pre>
  <h3 id="创建和添加到zip-文件">创建和添加到<code>ZIP</code> 文件</h3>
  <ul>
    <li>必须以“写模式”打开<code>ZipFile</code> 对象，即传入<code>'w'</code>作为第二个参数</li>
  </ul>
  <pre><code class="language-python"><div><span class="hljs-keyword">import</span> zipfile
exampleZip = zipfile.ZipFile(path,<span class="hljs-string">'w'</span>)
exampleZip.write(path,compress_type=zipfile.ZIP_DEFAULTED)
exampleZip.close()
</div></code></pre>
  <h3 id="将一个文件夹备份到一个zip-文件">将一个文件夹备份到一个<code>ZIP</code> 文件</h3>
  <ul>
    <li>递归添加到<code>ZIP</code>文件里面</li>
    <li><code>os.walk()</code></li>
  </ul>
  <h1 id="调试">调试</h1>
  <h2 id="抛出异常">抛出异常</h2>
  <ul>
    <li>抛出异常使用<code>raise</code> 语句。
      <ul>
        <li><code>raise</code> 关键字；</li>
        <li>对 <code>Exception</code> 函数的调用；</li>
        <li>传递给<code>Exception</code> 函数的字符串，包含有用的出错信息。</li>
      </ul>
    </li>
  </ul>
  <pre><code class="language-python"><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">boxPrint</span><span class="hljs-params">(symbol, width, height)</span>:</span>
  <span class="hljs-keyword">if</span> len(symbol) != <span class="hljs-number">1</span>:
    <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">'Symbol must be a single character string.'</span>)
  <span class="hljs-keyword">if</span> width &lt;= <span class="hljs-number">2</span>:
    <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">'Width must be greater than 2.'</span>)
  <span class="hljs-keyword">if</span> height &lt;= <span class="hljs-number">2</span>:
    <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">'Height must be greater than 2.'</span>)
  print(symbol * width)
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(height - <span class="hljs-number">2</span>):
    print(symbol + (<span class="hljs-string">' '</span> * (width - <span class="hljs-number">2</span>)) + symbol)
  print(symbol * width)
<span class="hljs-keyword">for</span> sym, w, h <span class="hljs-keyword">in</span> ((<span class="hljs-string">'*'</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>), (<span class="hljs-string">'O'</span>, <span class="hljs-number">20</span>, <span class="hljs-number">5</span>), (<span class="hljs-string">'x'</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>), (<span class="hljs-string">'ZZ'</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>)):
  <span class="hljs-keyword">try</span>:
    boxPrint(sym, w, h)
  <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> err:
    print(<span class="hljs-string">'An exception happened: '</span> + str(err))
</div></code></pre>
  <ul>
    <li>这个程序使用了<code>except</code> 语句的<code>except Exception as err</code>
      形式。如果<code>boxPrint()</code>返回一个<code>Exception</code> 对象，这条语句就会将它保存在名为<code>err</code>
      的变量中。<code>Exception</code> 对象可以传递给<code>str()</code>，将它转换为一个字符串，得到用户友好的出错信息</li>
  </ul>
  <h2 id="取得反向跟踪的字符串">取得反向跟踪的字符串</h2>
  <ul>
    <li>只要抛出的异常没有被处理，<code>Python</code> 就会显示反向跟踪。但你也可以调用<code>traceback.format_exc()</code>，得到它的字符串形式。</li>
    <li>如果你希望得到异常的反向跟踪的信息，但也希望<code>except</code> 语句优雅地处理该异常，这个函数就很有用</li>
    <li>需要导入<code>traceback</code> 模块。</li>
  </ul>
  <pre><code class="language-python"><div><span class="hljs-keyword">import</span> traceback
<span class="hljs-keyword">try</span>:
  <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">'This is the error message.'</span>)
<span class="hljs-keyword">except</span>:
  errorFile = open(<span class="hljs-string">'errorInfo.txt'</span>, <span class="hljs-string">'w'</span>)
  errorFile.write(traceback.format_exc())
  errorFile.close()
  print(<span class="hljs-string">'The traceback info was written to errorInfo.txt.'</span>)
<span class="hljs-comment"># 将反向跟踪信息写入一个日志文件，并让程序继续运行</span>
</div></code></pre>
  <h2 id="断言">断言</h2>
  <ul>
    <li><code>assert</code>语句包含以下部分：
      <code>assert</code> 关键字；
      条件（即求值为<code>True</code> 或<code>False</code> 的表达式）；
      逗号；
      当条件为<code>False</code> 时显示的字符串。</li>
    <li>当某些语句要在特定条件下才算正确执行，<code>assert</code>用在此处，可以让我们知道这里的运行条件不符合我们的预期（即便这些语句能够正常运行）</li>
  </ul>
  <pre><code class="language-python"><div>  podBayDoorStatus = <span class="hljs-string">'open'</span>
  <span class="hljs-keyword">assert</span> podBayDoorStatus == <span class="hljs-string">'open'</span>, <span class="hljs-string">'The pod bay doors need to be "open".'</span>
  podBayDoorStatus = <span class="hljs-string">'I\'m sorry, Dave. I\'m afraid I can'</span>t do that.<span class="hljs-string">''</span>
  <span class="hljs-keyword">assert</span> podBayDoorStatus == <span class="hljs-string">'open'</span>, <span class="hljs-string">'The pod bay doors need to be "open".'</span>
  <span class="hljs-comment"># 第二行不会抛出异常，字符串的值符合设定；第四行抛出异常，字符串的值不符合设定</span>
</div></code></pre>
  <h3 id="禁用断言">禁用断言</h3>
  <ul>
    <li>在运行<code>Python</code> 时传入<code>-O</code> 选项，可以禁用断言。</li>
    <li>参考附录B</li>
  </ul>
  <h2 id="日志">日志</h2>
  <p>记日志是一种很好的方式，可以理解程序中发生的事，以及事情发生的顺序。<code>Python</code> 的<code>logging</code>
    模块使得你很容易创建自定义的消息记录。这些日志消息将描述程序执行何时到达日志函数调用，并列出你指定的任何变量当时的值。另一方面，缺失日志信息表明有一部分代码被跳过，从未执行。</p>
  <h3 id="使用日志模块">使用日志模块</h3>
  <ul>
    <li>要启用<code>logging</code> 模块，在程序运行时将日志信息显示在屏幕上，请将下面的代码复制到<strong>程序顶部（但在<code>Python</code>
        的<code>#!</code>行之下）</strong>：</li>
  </ul>
  <pre><code class="language-python"><div><span class="hljs-keyword">import</span> logging
logging.basicConfig(level=logging.DEBUG, format=<span class="hljs-string">' %(asctime)s - %(levelname)s
- %(message)s'</span>)
</div></code></pre>
  <ul>
    <li>打印日志信息时，使用 <code>logging.debug()</code> 函数</li>
    <li>这个
      <code>debug()</code>函数将调用<code>basicConfig()</code>，打印一行信息。这行信息的格式是我们在<code>basicConfig()</code>函数中指定的，并且包括我们传递给<code>debug()</code>
      的消息。</li>
  </ul>
  <pre><code class="language-python"><div><span class="hljs-keyword">import</span> logging
logging.basicConfig(level=logging.DEBUG, format=<span class="hljs-string">' %(asctime)s - %(levelname)s
- %(message)s'</span>)
logging.debug(<span class="hljs-string">'Start of program'</span>)
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">factorial</span><span class="hljs-params">(n)</span>:</span>
  logging.debug(<span class="hljs-string">'Start of factorial(%s%%)'</span> % (n))
  total = <span class="hljs-number">1</span>
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n + <span class="hljs-number">1</span>):
    total *= i
    logging.debug(<span class="hljs-string">'i is '</span> + str(i) + <span class="hljs-string">', total is '</span> + str(total))
  logging.debug(<span class="hljs-string">'End of factorial(%s%%)'</span> % (n))
  <span class="hljs-keyword">return</span> total
print(factorial(<span class="hljs-number">5</span>))
logging.debug(<span class="hljs-string">'End of program'</span>)
</div></code></pre>
  <ul>
    <li>加入一次<code>logging.disable(logging.CRITICAL)</code>调用，就可以禁止日志</li>
  </ul>
  <h3 id="日志级别">日志级别</h3>
  <table>
    <thead>
      <tr>
        <th style="text-align:center">级别</th>
        <th style="text-align:right">日志函数</th>
        <th style="text-align:center">描述</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="text-align:center"><code>DEBUG</code></td>
        <td style="text-align:right"><code>logging.debug()</code></td>
        <td style="text-align:center">最低级别。用于小细节。通常只有在诊断问题时，你才会关心这些消息</td>
      </tr>
      <tr>
        <td style="text-align:center"><code>INFO</code></td>
        <td style="text-align:right"><code>logging.info()</code></td>
        <td style="text-align:center">用于记录程序中一般事件的信息，或确认一切工作正常</td>
      </tr>
      <tr>
        <td style="text-align:center"><code>WARNING</code></td>
        <td style="text-align:right"><code>logging.warning()</code></td>
        <td style="text-align:center">用于表示可能的问题，它不会阻止程序的工作，但将来可能会</td>
      </tr>
      <tr>
        <td style="text-align:center"><code>ERROR</code></td>
        <td style="text-align:right"><code>logging.error()</code></td>
        <td style="text-align:center">用于记录错误，它导致程序做某事失败</td>
      </tr>
      <tr>
        <td style="text-align:center"><code>CRITICAL</code></td>
        <td style="text-align:right"><code>logging.critical()</code></td>
        <td style="text-align:center">最高级</td>
      </tr>
    </tbody>
  </table>
  <ul>
    <li>日志级别的好处在于，你可以改变想看到的日志消息的优先级</li>
    <li>向<code>basicConfig()</code>函数传入<code>logging.DEBUG</code> 作为<code>level</code>
      关键字参数，这将显示所有日志级别的消息（<code>DEBUG</code>是最低的级别）</li>
    <li>将<code>basicConfig()</code> 的 <code>level</code>
      参数设置为<code>logging.ERROR</code>，这将只显示<code>ERROR</code>和<code>CRITICAL</code> 消息</li>
  </ul>
  <h3 id="禁用日志">禁用日志</h3>
  <ul>
    <li>只要向<code>logging.disable()</code> 传入一个日志级别，它就会<strong>禁止该级别和更低级别</strong>的所有日志消息</li>
  </ul>
  <h3 id="将日志记录到文件">将日志记录到文件</h3>
  <ul>
    <li><code>logging.basicConfig()</code> 函数接受<code>filename</code> 关键字参数</li>
  </ul>
  <pre><code class="language-python"><div><span class="hljs-keyword">import</span> logging
logging.basicConfig(filename=<span class="hljs-string">'myProgramLog.txt'</span>, level=logging.DEBUG, format=<span class="hljs-string">'%(asctime)s - %(levelname)s - %(message)s'</span>)
<span class="hljs-comment"># 日志信息将被保存到myProgramLog.txt 文件中</span>
</div></code></pre>
  <h1 id="从web-抓取信息">从Web 抓取信息</h1>
  <ul>
    <li><code>webbrowser</code>：是Python 自带的，打开浏览器获取指定页面。</li>
    <li><code>requests</code>：从因特网上下载文件和网页。</li>
    <li><code>Beautiful Soup</code>：解析HTML，即网页编写的格式。</li>
    <li><code>selenium</code>：启动并控制一个<code>Web</code>浏览器。<code>selenium</code>能够填写表单，并模拟鼠标在这个浏览器中点击。
      ##<code>webbrowser</code> 模块</li>
  </ul>
  <pre><code class="language-python"><div>  <span class="hljs-keyword">import</span> webbrowser
  webbrowser.open(<span class="hljs-string">'http://inventwithpython.com/'</span>)
</div></code></pre>
  <h2 id="用requests-模块从web-下载文件">用<code>requests</code> 模块从<code>Web</code> 下载文件</h2>
  <h3 id="用requestsget函数下载一个网页">用<code>requests.get()</code>函数下载一个网页</h3>
  <pre><code class="language-python"><div><span class="hljs-keyword">import</span> requests
res = requests.get(<span class="hljs-string">'http://www.gutenberg.org/cache/epub/1112/pg1112.txt'</span>)
print(res.text[:<span class="hljs-number">250</span>])
</div></code></pre>
  <ul>
    <li>。通过检查<code>Response</code> 对象的<code>status_code</code>
      属性，你可以了解对这个网页的请求是否成功。如果该值等于<code>requests.codes.ok</code>，那么一切都好（顺便说一下，<code>HTTP</code>协议中“<code>OK</code>”的状态码是<code>200</code>。你可能已经熟悉<code>404</code>
      状态码，它表示“没找到”）</li>
    <li>如果请求成功，下载的页面就作为一个字符串，保存在<code>Response</code> 对象的<code>text</code>变量中</li>
  </ul>
  <h3 id="检查错误">检查错误</h3>
  <ul>
    <li>。检查成功有一种简单的方法，就是在<code>Response</code>对象上调用<code>raise_for_status()</code>方法。如果下载文件出错，这将抛出异常。如果下载成功，就什么也不做。</li>
  </ul>
  <h3 id="将下载的文件保存到硬盘">将下载的文件保存到硬盘</h3>
  <ul>
    <li>必须用“写二进制”模式打开该文件，即向函数传入字符串<code>'wb'</code>，作为<code>open()</code>的第二参数。</li>
    <li>目的是为了保存该文本中的“<code>Unicode</code> 编码”。</li>
  </ul>
  <h2 id="用beautifulsoup-模块解析html">用<code>BeautifulSoup</code> 模块解析<code>HTML</code></h2>
  <h3 id="从html-创建一个beautifulsoup-对象">从<code>HTML</code> 创建一个<code>BeautifulSoup</code> 对象</h3>
  <pre><code class="language-python"><div><span class="hljs-keyword">import</span> requests, bs4
res = requests.get(<span class="hljs-string">'http://nostarch.com'</span>)
res.raise_for_status()
noStarchSoup = bs4.BeautifulSoup(res.text)
<span class="hljs-comment"># 将响应结果的text 属性传递给bs4.BeautifulSoup()</span>
</div></code></pre>
  <ul>
    <li>也可以向<code>bs4.BeautifulSoup()</code>传递一个<code>File</code> 对象，从硬盘加载一个<code>HTML</code> 文件</li>
  </ul>
  <pre><code class="language-python"><div>exampleFile = open(<span class="hljs-string">'example.html'</span>)
exampleSoup = bs4.BeautifulSoup(exampleFile)
</div></code></pre>
  <h3 id="用select方法寻找元素">用<code>select()</code>方法寻找元素</h3>
  <table>
    <thead>
      <tr>
        <th>传递给 <code>select()</code>方法的选择器</th>
        <th>将匹配…</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>soup.select('div')</code></td>
        <td>所有名为<code>&lt;div&gt;</code>的元素</td>
      </tr>
      <tr>
        <td><code>soup.select('#author')</code></td>
        <td>带有 <code>id</code> 属性为<code>author</code> 的元素</td>
      </tr>
      <tr>
        <td><code>soup.select('.notice')</code></td>
        <td>所有使用<code>CSS class</code> 属性名为<code>notice</code> 的元素</td>
      </tr>
      <tr>
        <td><code>soup.select('div span')</code></td>
        <td>所有在<code>&lt;div&gt;</code>元素之内的<code>&lt;span&gt;</code>元素</td>
      </tr>
      <tr>
        <td><code>soup.select('div &gt; span')</code></td>
        <td>所有直接在<div>元素之内的<code>&lt;span&gt;</code>元素，中间没有其他元素</td>
      </tr>
      <tr>
        <td><code>soup.select('input[name]')</code></td>
        <td>所有名为<code>&lt;input&gt;</code>，并有一个<code>name</code> 属性，其值无所谓的元素</td>
      </tr>
      <tr>
        <td><code>soup.select('input[type=&quot;button&quot;]')</code></td>
        <td>所有名为<code>&lt;input&gt;</code>，并有一个<code>type</code> 属性，其值为<code>button</code> 的元素</td>
      </tr>
    </tbody>
  </table>
  <ul>
    <li>
      <code>select()</code>返回一个列表，列表中元素为<code>Tag</code>对象。在该元素上调用<code>getText()</code>方法，返回该元素的文本，或内部的<code>HTML</code>。一个元素的文本是在开始和结束标签之间的内容
    </li>
    <li><code>Tag</code> 对象的<code>get()</code>方法让我们很容易从元素中获取属性值。向该方法传入一个属性名称的字符串，它将返回该属性的值。</li>
  </ul>
  <h2 id="用selenium-模块控制浏览器">用<code>selenium</code> 模块控制浏览器</h2>
  <p>需要安装<code>driver</code>驱动
    对于<code>chrome</code>浏览器</p>
  <pre><code class="language-python"><div><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver
browser = webdriver.Chrome()
browser.get(<span class="hljs-string">'http://inventwithpython.com'</span>)
<span class="hljs-comment"># 将浏览器指向该网址</span>
</div></code></pre>
  <h3 id="在页面中寻找元素">在页面中寻找元素</h3>
  <ul>
    <li><code>WebDriver</code>
      对象有好几种方法，用于在页面中寻找元素。它们被分成<code>find_element_*</code>和<code>find_elements_*</code>方法，前者返回一个对象，后者返回一个列表</li>
  </ul>
  <table>
    <thead>
      <tr>
        <th>方法名</th>
        <th>返回的WebElement 对象/列表</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>browser.find_element_by_class_name(name)</code>
          <br><code>browser.find_elements_by_class_name(name)</code></td>
        <td>使用 <code>CSS</code> 类<code>name</code> 的元素</td>
      </tr>
      <tr>
        <td>
          <code>browser.find_element_by_css_selector(selector)</code><br><code>browser.find_elements_by_css_selector(selector)</code>
        </td>
        <td>匹配 <code>CSS selector</code> 的元素</td>
      </tr>
      <tr>
        <td><code>browser.find_element_by_id(id)</code><br><code>browser.find_elements_by_id(id)</code></td>
        <td>匹配 <code>id</code> 属性值的元素</td>
      </tr>
      <tr>
        <td>
          <code>browser.find_element_by_link_text(text)</code><br><code>browser.find_elements_by_link_text(text)</code>
        </td>
        <td>完全匹配提供的<code>text</code> 的<code>&lt;a&gt;</code>元素</td>
      </tr>
      <tr>
        <td>
          <code>browser.find_element_by_partial_link_text(text)</code><br><code>browser.find_elements_by_partial_link_text(text)</code>
        </td>
        <td>包含提供的<code>text</code> 的<code>&lt;a&gt;</code>元素</td>
      </tr>
      <tr>
        <td><code>browser.find_element_by_name(name)</code><br><code>browser.find_elements_by_name(name)</code></td>
        <td>匹配 <code>name</code> 属性值的元素</td>
      </tr>
      <tr>
        <td><code>browser.find_element_by_tag_name(name)</code><br><code>browser.find_elements_by_tag_name(name)</code>
        </td>
        <td>匹配标签<code>name</code> 的元素<code>&lt;br&gt;</code>(大小写无关，<code>&lt;a&gt;</code>元素匹配'a'和'A')</td>
      </tr>
    </tbody>
  </table>
  <h3 id="点击页面">点击页面</h3>
  <ul>
    <li><code>find_element_*</code>和<code>find_elements_*</code>方法返回的<code>WebElement</code>
      对象有一个<code>click()</code>方法，模拟鼠标在该元素上点击</li>
  </ul>
  <pre><code class="language-python"><div><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver
browser = webdriver.Firefox()
browser.get(<span class="hljs-string">'http://inventwithpython.com'</span>)
linkElem = browser.find_element_by_link_text(<span class="hljs-string">'Read It Online'</span>)
type(linkElem)
linkElem.click() <span class="hljs-comment"># follows the "Read It Online" link</span>
</div></code></pre>
  <h3 id="填写并提交表单">填写并提交表单</h3>
  <ul>
    <li>向<code>Web</code>
      页面的文本字段发送击键，只要找到那个文本字段的<code>&lt;input&gt;</code>或<code>&lt;textarea&gt;</code>元素，然后调用<code>send_keys()</code>方法。
    </li>
  </ul>
  <pre><code class="language-python"><div><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver
browser = webdriver.Firefox()
browser.get(<span class="hljs-string">'http://gmail.com'</span>)
emailElem = browser.find_element_by_id(<span class="hljs-string">'Email'</span>)
emailElem.send_keys(<span class="hljs-string">'not_my_real_email@gmail.com'</span>)
passwordElem = browser.find_element_by_id(<span class="hljs-string">'Passwd'</span>)
passwordElem.send_keys(<span class="hljs-string">'12345'</span>)
passwordElem.submit()
</div></code></pre>
  <ul>
    <li>在任何元素上调用<code>submit()</code>方法，都等同于点击该元素所在表单的<code>Submit</code> 按钮</li>
  </ul>
  <h3 id="发送特殊键">发送特殊键</h3>
  <ul>
    <li>这些值保存在<code>selenium.webdriver.common.keys</code> 模块的属性中</li>
  </ul>
  <table>
    <thead>
      <tr>
        <th>属性</th>
        <th>含义</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Keys.DOWN, Keys.UP, Keys.LEFT,Keys.RIGHT</td>
        <td>键盘箭头键</td>
      </tr>
      <tr>
        <td>Keys.ENTER, Keys.RETURN</td>
        <td>回车和换行键</td>
      </tr>
      <tr>
        <td>Keys.HOME, Keys.END,Keys.PAGE_DOWN,Keys.PAGE_UP</td>
        <td>Home 键、End 键、PageUp 键和Page Down 键</td>
      </tr>
      <tr>
        <td>Keys.ESCAPE, Keys.BACK_SPACE,Keys.DELETE Esc、</td>
        <td>Backspace 和字母键</td>
      </tr>
      <tr>
        <td>Keys.F1, Keys.F2, . . . , Keys.F12</td>
        <td>键盘顶部的F1 到F12 键</td>
      </tr>
      <tr>
        <td>Keys.TAB</td>
        <td>Tab 键</td>
      </tr>
    </tbody>
  </table>
  <h3 id="点击浏览器按钮">点击浏览器按钮</h3>
  <p><code>browser.back()</code>点击“返回”按钮。
    <code>browser.forward()</code>点击“前进”按钮。
    <code>browser.refresh()</code>点击“刷新”按钮。
    <code>browser.quit()</code>点击“关闭窗口”按钮。</p>
  <h1 id="处理excel-电子表格">处理Excel 电子表格</h1>
  <h2 id="openpyxl"><code>openpyxl</code></h2>
  <h1 id="处理pdf-和word-文档">处理PDF 和Word 文档</h1>
  <h2 id="pypdf2">PyPDF2</h2>
  <h2 id="docx">docx</h2>
  <h1 id="处理csv-文件和json-数据">处理CSV 文件和JSON 数据</h1>
  <h2 id="csv-模块">csv 模块</h2>
  <h2 id="json模块">json模块</h2>
  <h1 id="保持时间计划任务和启动程序">保持时间、计划任务和启动程序</h1>
  <ul>
    <li><code>time</code> 和<code>datetime</code> 模块</li>
    <li>利用<code>subprocess</code> 和<code>threading</code> 模块，你也可以编程按时启动其他程序</li>
  </ul>
  <h2 id="time-模块"><code>time</code> 模块</h2>
  <h3 id="timetime函数"><code>time.time()</code>函数</h3>
  <ul>
    <li><code>Unix</code> 纪元是编程中经常参考的时间：1970 年1 月1 日0 点，即协调世界时<code>（UTC）</code></li>
    <li><code>time.time()</code>函数返回自那一刻以来的秒数，是一个浮点值，这个数字称为<code>UNIX</code> 纪元时间戳</li>
  </ul>
  <pre><code class="language-python"><div><span class="hljs-keyword">import</span> time
time.time()
</div></code></pre>
  <h3 id="timesleep函数"><code>time.sleep()</code>函数</h3>
  <ul>
    <li>暂停程序</li>
    <li>，在<code>IDLE</code> 中按<code>Ctrl-C</code> 不会中断<code>time.sleep()</code>调用。<code>IDLE</code>
      会等待到暂停结束，再抛出<code>KeyboardInterrupt</code> 异常</li>
  </ul>
  <h2 id="datetime-模块"><code>datetime</code> 模块</h2>
  <ul>
    <li><code>datetime</code> 模块有自己的<code>datetime</code> 数据类型。<code>datetime</code> 值表示一个特定的时刻</li>
    <li>调用<code>datetime.datetime.now()</code>返回一个<code>datetime</code>
      对象，表示当前的日期和时间，根据你的计算机的时钟。这个对象包含当前时刻的年、月、日、时、分、秒和微秒</li>
    <li>也可以利用<code>datetime.datetime()</code>函数，向它传入代表年、月、日、时、分、秒的整数，得到特定时刻的<code>datetime</code>
      对象。这些整数将保存在<code>datetime</code> 对象的<code>year、month、day、hour、minute </code>和<code>second</code>属性中。</li>
    <li><code>Unix</code> 纪元时间戳可以通过<code>datetime.datetime.fromtimestamp()</code>，转换为<code>datetime</code>对象</li>
  </ul>
  <h3 id="timedelta-数据类型"><code>timedelta</code> 数据类型</h3>
  <ul>
    <li><code>datetime</code> 模块还提供了<code>timedelta</code> 数据类型，它表示一段时间，而不是一个时刻。</li>
    <li>
      <code>datetime.timedelta()</code>函数接受关键字参数<code>weeks、days、hours、minutes、seconds、milliseconds 和microseconds</code>。没有<code>month 和yea</code>r
      关键字参数，因为“月”和“年”是可变的时间</li>
    <li><code>total_seconds()</code>方法返回只以秒表示的时间</li>
    <li>算术运算符可以用于对<code>datetime</code> 值进行日期运算</li>
  </ul>
  <pre><code class="language-python"><div>dt = datetime.datetime.now()
thousandDays = datetime.timedelta(days=<span class="hljs-number">1000</span>)
dt + thousandDays
<span class="hljs-comment"># datetime.datetime(2017, 11, 23, 18, 38, 50, 636181)</span>
</div></code></pre>
  <h3 id="将datetime-对象转换为字符串">将<code>datetime</code> 对象转换为字符串</h3>
  <ul>
    <li><code>strftime()</code></li>
  </ul>
  <table>
    <thead>
      <tr>
        <th>strftime指令</th>
        <th>含义，</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>%Y</td>
        <td>带世纪的年份，例如'2014'，</td>
      </tr>
      <tr>
        <td>%y</td>
        <td>不带世纪的年份，'00'至'99'（1970 至2069），00'至'99'（1970 至2069）</td>
      </tr>
      <tr>
        <td>%m</td>
        <td>数字表示的月份，'01'至'12'，01'至'12'</td>
      </tr>
      <tr>
        <td>%B</td>
        <td>完整的月份，例如'November'，</td>
      </tr>
      <tr>
        <td>%b</td>
        <td>简写的月份，例如'Nov'，</td>
      </tr>
      <tr>
        <td>%d</td>
        <td>一月中的第几天，'01'至'31'，</td>
      </tr>
      <tr>
        <td>%j</td>
        <td>一年中的第几天，'001'至'366'，</td>
      </tr>
      <tr>
        <td>%w</td>
        <td>一周中的第几天，'0'（周日）至'6'（周六），</td>
      </tr>
      <tr>
        <td>%A</td>
        <td>完整的周几，例如'Monday'，</td>
      </tr>
      <tr>
        <td>%a</td>
        <td>简写的周几，例如'Mon'，</td>
      </tr>
      <tr>
        <td>%H</td>
        <td>小时（24 小时时钟），'00'至'23'，</td>
      </tr>
      <tr>
        <td>%I</td>
        <td>小时（12 小时时钟），'01'至'12'，</td>
      </tr>
      <tr>
        <td>%M</td>
        <td>分，'00'至'59'，</td>
      </tr>
      <tr>
        <td>%S</td>
        <td>秒，'00'至'59'，</td>
      </tr>
      <tr>
        <td>%p</td>
        <td>'AM'或'PM'，</td>
      </tr>
      <tr>
        <td>%%</td>
        <td>就是'%'字符，</td>
      </tr>
    </tbody>
  </table>
  <ul>
    <li>
      向<code>strftime()</code>传入一个定制的格式字符串，其中包含格式化指定（以及任何需要的斜线、冒号等），<code>strftime()</code>将返回一个格式化的字符串，表示<code>datetime</code>
      对象的信息。</li>
  </ul>
  <pre><code class="language-python"><div>oct21st = datetime.datetime(<span class="hljs-number">2015</span>, <span class="hljs-number">10</span>, <span class="hljs-number">21</span>, <span class="hljs-number">16</span>, <span class="hljs-number">29</span>, <span class="hljs-number">0</span>)
oct21st.strftime(<span class="hljs-string">'%Y/%m/%d %H:%M:%S'</span>)
<span class="hljs-comment"># '2015/10/21 16:29:00'</span>
oct21st.strftime(<span class="hljs-string">'%I:%M %p'</span>)
<span class="hljs-comment"># '04:29 PM'</span>
oct21st.strftime(<span class="hljs-string">"%B of '%y"</span>)
<span class="hljs-comment"># "October of '15"</span>
</div></code></pre>
  <h3 id="将字符串转换成datetime-对象">将字符串转换成<code>datetime</code> 对象</h3>
  <pre><code class="language-python"><div>datetime.datetime.strptime(<span class="hljs-string">'October 21, 2015'</span>, <span class="hljs-string">'%B %d, %Y'</span>)
<span class="hljs-comment"># datetime.datetime(2015, 10, 21, 0, 0)</span>
datetime.datetime.strptime(<span class="hljs-string">'2015/10/21 16:29:00'</span>, <span class="hljs-string">'%Y/%m/%d %H:%M:%S'</span>)
<span class="hljs-comment"># datetime.datetime(2015, 10, 21, 16, 29)</span>
datetime.datetime.strptime(<span class="hljs-string">"October of '15"</span>, <span class="hljs-string">"%B of '%y"</span>)
<span class="hljs-comment"># datetime.datetime(2015, 10, 1, 0, 0)</span>
datetime.datetime.strptime(<span class="hljs-string">"November of '63"</span>, <span class="hljs-string">"%B of '%y"</span>)
<span class="hljs-comment"># datetime.datetime(2063, 11, 1, 0, 0)</span>
</div></code></pre>
  <h2 id="多线程">多线程</h2>
  <h3 id="创建一个thread-对象">创建一个<code>Thread</code> 对象</h3>
  <pre><code class="language-python"><div><span class="hljs-keyword">import</span> threading
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">takeANap</span><span class="hljs-params">()</span>:</span>
  time.sleep(<span class="hljs-number">5</span>)
  print(<span class="hljs-string">'Wake up!'</span>)
threadObj = threading.Thread(target=takeANap)
threadObj.start()
</div></code></pre>
  <h3 id="向线程的目标函数传递参数">向线程的目标函数传递参数</h3>
  <pre><code class="language-pythpn"><code><div>import threading
threadObj = threading.Thread(target=print, args=['Cats', 'Dogs', 'Frogs'],kwargs={'sep': ' &amp; '})
</div></code></code></pre>
  <h2 id="从python-启动其他程序">从<code>Python</code> 启动其他程序</h2>
  <ul>
    <li><code>subprocess</code> 模块</li>
  </ul>
  <pre><code class="language-python"><div><span class="hljs-keyword">import</span> subprocess
subprocess.Popen(<span class="hljs-string">'C:\\Windows\\System32\\calc.exe'</span>)
</div></code></pre>
  <h3 id="popen对象"><code>Popen</code>对象</h3>
  <ul>
    <li><code>poll()和wait()</code></li>
    <li>
      如果这个进程在<code>poll()</code>调用时仍在运行，<code>poll()</code>方法就返回<code>None</code>。如果该程序已经终止，它会返回该进程的整数退出代码。退出代码用于说明进程是无错终止（退出代码为0），还是一个错误导致进程终止（退出代码非零，通常为1，但可能根据程序而不同）。
    </li>
    <li><code>wait()</code>方法将阻塞，直到启动的进程终止</li>
  </ul>
  <h3 id="向popen传递命令行参数">向<code>Popen()</code>传递命令行参数</h3>
  <ul>
    <li>
      向<code>Popen()</code>传递一个列表，作为唯一的参数。该列表中的第一个字符串是要启动的程序的可执行文件名，所有后续的字符串将是该程序启动时，传递给该程序的命令行参数。实际上，这个列表将作为被启动程序的<code>sys.argv</code>
      的值。</li>
  </ul>
  <pre><code class="language-python"><div>subprocess.Popen([<span class="hljs-string">'C:\\Windows\\notepad.exe'</span>, <span class="hljs-string">'C:\\hello.txt'</span>])
</div></code></pre>
  <h3 id="用默认的应用程序打开文件">用默认的应用程序打开文件</h3>
  <ul>
    <li>根据操作系统，向<code>Popen()传入'start'、'open'或'see'</code>，分别代表<code>windows、OS X、Linux</code></li>
  </ul>
  <pre><code class="language-python"><div>fileObj = open(<span class="hljs-string">'hello.txt'</span>, <span class="hljs-string">'w'</span>)
fileObj.write(<span class="hljs-string">'Hello world!'</span>)
<span class="hljs-comment"># 12</span>
fileObj.close()
<span class="hljs-keyword">import</span> subprocess
subprocess.Popen([<span class="hljs-string">'start'</span>, <span class="hljs-string">'hello.txt'</span>], shell=<span class="hljs-literal">True</span>)
<span class="hljs-comment"># 传入了shell=True 关键字参数，这只在Windows 上需要</span>
</div></code></pre>
  <h1 id="发送电子邮件和短信">发送电子邮件和短信</h1>
  <h1 id="操-作-图-像">操 作 图 像</h1>
  <h2 id="pillow模块"><code>pillow</code>模块</h2>
  <h3 id="颜色和rgba-值">颜色和<code>RGBA</code> 值</h3>
  <ul>
    <li><code>RGBA</code>值是一组数字，指定顔色中的**红、绿、蓝和<code>alpha</code>（透明度）**的值。这些值是从0（根本没有）到255（最高）的整数</li>
    <li>
      在<code>Pillow</code>中，<code>RGBA</code>值表示为四个整数值的元组。例如，红色表示为（255，0，0，255）。这种颜色中红的值为最大，没有绿和蓝，并且<code>alpha</code>值最大，这意味着它完全不透明。
    </li>
    <li>如果颜色的<code>alpha</code>值为0，不论<code>RGB</code>值是什么，该颜色是不可见的</li>
    <li><code>Pillow</code>提供<code>ImageColor.getcolor()</code>函数，该函数接受一个颜色名称字符串作为第一个参数，字符串'RGBA'作为第二个参数，返回一个RGBA元组</li>
  </ul>
  <pre><code class="language-python"><div><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> ImageColor
ImageColor.getcolor(<span class="hljs-string">'red'</span>, <span class="hljs-string">'RGBA'</span>)
<span class="hljs-comment"># (255, 0, 0, 255)</span>
ImageColor.getcolor(<span class="hljs-string">'RED'</span>, <span class="hljs-string">'RGBA'</span>)
<span class="hljs-comment"># (255, 0, 0, 255)</span>
ImageColor.getcolor(<span class="hljs-string">'Black'</span>, <span class="hljs-string">'RGBA'</span>)
<span class="hljs-comment"># (0, 0, 0, 255)</span>
ImageColor.getcolor(<span class="hljs-string">'chocolate'</span>, <span class="hljs-string">'RGBA'</span>)
<span class="hljs-comment"># (210, 105, 30, 255)</span>
ImageColor.getcolor(<span class="hljs-string">'CornflowerBlue'</span>, <span class="hljs-string">'RGBA'</span>)
<span class="hljs-comment"># (100, 149, 237, 255)</span>
</div></code></pre>
  <h3 id="坐标和box元组">坐标和<code>Box</code>元组</h3>
  <ul>
    <li>图像像素用<code>x</code>和<code>y</code>坐标指定，分别指定像素在图像中的水平和垂直位置。原点是位于图像左上角的像素，用符号<code>(0，0)</code>指定</li>
    <li>许多Pillow函数和方法需要一个矩形元组参数。这意味着Pillow需要一个四个整坐标的元组，表示图像中的一个矩形区域。四个整数按顺序分别是：
      <ul>
        <li>左：该矩形的最左边的x坐标</li>
        <li>顶：该矩形的顶边的y坐标。</li>
        <li>右：该矩形的最右边右面一个像素的x坐标。此整数必须比左边整数大。</li>
        <li>底：该矩形的底边下面一个像素的y坐标。此整数必须比顶边整数大。注意，该矩形包括左和顶坐标，直到但不包括右和底坐标。</li>
      </ul>
    </li>
  </ul>
  <h2 id="用-pillow操作图像">用 <code>Pillow</code>操作图像</h2>
  <h3 id="image模块"><code>Image</code>模块</h3>
  <ul>
    <li><code>Image.open()</code>函数的返回值是<code>Image</code>对象数据类型</li>
  </ul>
  <pre><code class="language-python"><div><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image
catIm = Image.open(path)
</div></code></pre>
  <h3 id="处理-image数据类型">处理 <code>Image</code>数据类型</h3>
  <pre><code class="language-python"><div><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image
catIm = Image.open(<span class="hljs-string">'zophie.png'</span>)
catIm.size
<span class="hljs-comment"># (816, 1088)</span>
width, height = catIm.size
width
<span class="hljs-comment"># 816 </span>
height
<span class="hljs-comment"># 1088 </span>
catIm.filename
<span class="hljs-comment"># 'zophie.png'</span>
catIm.format
<span class="hljs-comment"># 'PNG'</span>
catIm.format_description
<span class="hljs-comment"># 'Portable network graphics'</span>
atIm.save(<span class="hljs-string">'zophie.jpg'</span>)
</div></code></pre>
  <ul>
    <li><code>Image.new()</code>函数，它返回一个 <code>Image</code>对象,对象表示空白的图像。</li>
  </ul>
  <pre><code class="language-python"><div><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image
im = Image.new(<span class="hljs-string">'RGBA'</span>,(<span class="hljs-number">100</span>,<span class="hljs-number">200</span>),<span class="hljs-string">'purple'</span>)
<span class="hljs-comment"># 100像素宽，200像素高，带有紫色背景</span>
im.save(path)
im2 = Image.new(<span class="hljs-string">'RGBA'</span>,(<span class="hljs-number">20</span>,<span class="hljs-number">20</span>))
im2.save(path)
</div></code></pre>
  <h3 id="裁剪图片">裁剪图片</h3>
  <ul>
    <li><code>Image</code>对象的<code>crop()</code>方法，接受一个元组，返回一个<code>Image</code>对象，表示被裁剪后的图像</li>
  </ul>
  <h3 id="复制和粘贴图像到其他图像">复制和粘贴图像到其他图像</h3>
  <pre><code class="language-python"><div>catCopy.paste(Image,(x,y))
</div></code></pre>
  <h3 id="调整图像大小">调整图像大小</h3>
  <ul>
    <li><code>resize()</code>方法在<code>Image</code>对象上调用，回指定宽度和高度的一个新<code>Image</code>对象，它接受两个整数的元组作为参数，表示返回图像的新高度和宽度。
    </li>
  </ul>
  <h3 id="旋转和翻转图像">旋转和翻转图像</h3>
  <ul>
    <li><code>Image</code>对象的<code>rotate()</code>旋转图像，返回旋转后的新<code>Image</code>对象</li>
  </ul>
  <pre><code class="language-python"><div>catIm.rotate(<span class="hljs-number">90</span>).save(path)
<span class="hljs-comment"># 旋转90°</span>
</div></code></pre>
  <h3 id="更改单个像素">更改单个像素</h3>
  <pre><code class="language-python"><div>im.getpixel((x,y))
im.getpixel((x,y),(R,G,B))
</div></code></pre>
  <h2 id="在图像上绘画">在图像上绘画</h2>
  <ul>
    <li><code>Pillow</code>的<code>ImageDraw</code>模块</li>
    <li><code>ImageDraw</code>对象</li>
  </ul>
  <pre><code class="language-python"><div><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image,ImageDraw
im = Image.new(RGBA,(x,y),color)
draw = ImageDraw.Draw(im)
draw.line([(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">199</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">199</span>, <span class="hljs-number">199</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">199</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)], fill=<span class="hljs-string">'black'</span>)
</div></code></pre>
  <h3 id="绘制形状">绘制形状</h3>
  <ul>
    <li><strong>这些方法的<code>fill</code>和<code>outline</code>参数是可选的，如果未指定，默认为白色。</strong></li>
  </ul>
  <table>
    <thead>
      <tr>
        <th style="text-align:center">形状</th>
        <th style="text-align:center">函数</th>
        <th style="text-align:center">注意</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="text-align:center">点</td>
        <td style="text-align:center"><code>point((xy),fill)</code></td>
        <td style="text-align:center">
          <code>xy</code>表示<code>x和y</code>坐标的列表，例如<code>[(x,y),(x,y)...]</code>和<code>[x,y,x,y...]</code><br><code>fill</code>参数是点的颜色，要么是一个<code>RGBA</code>元组，要么是颜色名称的字符串
        </td>
      </tr>
      <tr>
        <td style="text-align:center">线</td>
        <td style="text-align:center"><code>line((xy),fill,width)</code></td>
        <td style="text-align:center">
          <code>xy</code>表示<code>x和y</code>坐标的列表，例如<code>[(x,y),(x,y)...]</code>和<code>[x,y,x,y...]</code><br><code>fill</code>参数是点的颜色，要么是一个<code>RGBA</code>元组，要么是颜色名称的字符串<br>可选的<code>width</code>参数是线的宽度，如果未指定，缺省值为1
        </td>
      </tr>
      <tr>
        <td style="text-align:center">矩形</td>
        <td style="text-align:center"><code>rectangle((xy),fill,outline)</code></td>
        <td style="text-align:center">
          <code>xy</code>参数是一个矩形元组，形式为<code>(left, top,  right,  bottom)</code><br>选的<code>fill</code>参数是颜色，将填充该矩形的内部。可选的<code>outline</code>参数是矩形轮廓的颜色
        </td>
      </tr>
      <tr>
        <td style="text-align:center">椭圆</td>
        <td style="text-align:center"><code>ellipse((xy),fill)</code></td>
        <td style="text-align:center">
          <code>xy</code>参数是一个矩形元组<code>(left, top, right, bottom)</code>，它表示正好包含该椭圆的矩形。<br>可选的fill参数是椭圆内的颜色，<br>可选的outline参数是椭圆轮廓的颜色
        </td>
      </tr>
      <tr>
        <td style="text-align:center">多边形</td>
        <td style="text-align:center"><code>polygon((xy),fill)</code></td>
        <td style="text-align:center">同矩形</td>
      </tr>
    </tbody>
  </table>
  <h3 id="绘制文本">绘制文本</h3>
  <p>ImageDraw对象还有text()方法，用于在图像上绘制文本。text()方法有4个参数：<code>xy、text、fill和font</code></p>
  <ul>
    <li><code>xy</code>参数是两个整数的元组，指定文本区域的左上角</li>
    <li><code>text</code>参数是想写入的文本字符串</li>
    <li>可选参数<code>fill</code>是文本的颜色</li>
    <li>可选参数<code>font</code>是一个<code>ImageFont</code>对象，用于设置文本的字体和大小。需要导入<code>ImageFont</code>模块</li>
    <li>
      导入<code>Pillow</code>的<code>ImageFont</code>模块，就可以调用<code>ImageFont.truetype()</code>函数，它有两个参数。第一个参数是字符串，表示字体的<code>TrueType</code>文件，这是硬盘上实际的字体文件
    </li>
    <li>第二个参数是一个整数，表示字体大小的点数（而不是像素）。请记住，<code>Pillow</code>创建的<code>PNG</code>图像默认是每英寸72像素，一点是1/72英寸</li>
  </ul>
  <pre><code class="language-python"><div><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image, ImageDraw, ImageFont
<span class="hljs-keyword">import</span> os
im = Image.new(<span class="hljs-string">'RGBA'</span>, (<span class="hljs-number">200</span>, <span class="hljs-number">200</span>), <span class="hljs-string">'white'</span>)
draw = ImageDraw.Draw(im)
draw.text((<span class="hljs-number">20</span>, <span class="hljs-number">150</span>), <span class="hljs-string">'Hello'</span>, fill=<span class="hljs-string">'purple'</span>)
fontsFolder = <span class="hljs-string">'FONT_FOLDER'</span> <span class="hljs-comment"># e.g. ‘/Library/Fonts’</span>
arialFont = ImageFont.truetype(os.path.join(fontsFolder, <span class="hljs-string">'arial.ttf'</span>), <span class="hljs-number">32</span>)
draw.text((<span class="hljs-number">100</span>, <span class="hljs-number">150</span>), <span class="hljs-string">'Howdy'</span>, fill=<span class="hljs-string">'gray'</span>, font=arialFont)
im.save(<span class="hljs-string">'text.png'</span>)
</div></code></pre>
  <h1 id="用gui自动化控制键盘和鼠标">用<code>GUI</code>自动化控制键盘和鼠标</h1>
  <ul>
    <li><code>pyautogui</code>模块</li>
  </ul>
  <h2 id="走对路">走对路</h2>
  <h3 id="通过注销关闭所有程序">通过注销关闭所有程序</h3>
  <ul>
    <li>在<code>Windows</code>和<code>Linux</code>上，注销的热键是<code>Ctrl-Alt-Del</code>。</li>
  </ul>
  <h3 id="暂停和自动防故障装置">暂停和自动防故障装置</h3>
  <ul>
    <li>将<code>pyautogui.PAUSE</code>变量设置为要暂停的秒数,每个<code>PyAutoGUI</code>函数调用在执行动作之后，都会等待指定的时间</li>
    <li>·pyautogui·也有自动防故障功能。将鼠标移到屏幕的左上角，这将导致<code>pyautogui</code>产生<code>pyautogui  .FailSafeException</code>异常</li>
    <li>如果你尽可能快地向左上移动鼠标，自动防故障功能都将停止程序;可以设置<code>pyautogui.FAILSAFE = False</code>，禁止这项功能。</li>
  </ul>
  <h2 id="控制鼠标移动">控制鼠标移动</h2>
  <ul>
    <li><code>pyautogui.size()</code>函数返回两个整数的元组，包含屏幕的宽和高的像素数</li>
  </ul>
  <h3 id="移动鼠标">移动鼠标</h3>
  <ul>
    <li>
      <code>pyautogui.moveTo(x,y,duration)</code>;<code>(x,y)</code>表示移动的目的地位置，可选的<code>duration</code>整数或浮点数关键字参数，指定了将鼠标移动到目的地所需要的秒数
    </li>
  </ul>
  <pre><code class="language-python"><div><span class="hljs-keyword">import</span> pyautogui
pyautogui.moveTo(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,duration=<span class="hljs-number">0.25</span>)
</div></code></pre>
  <ul>
    <li><code>pyautogui.moveRel()</code>函数相对于<strong>当前的位置</strong>移动鼠标</li>
  </ul>
  <pre><code class="language-python"><div>pyautogui.moveRel(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,duration=<span class="hljs-number">0.25</span>)
</div></code></pre>
  <h3 id="获取鼠标位置">获取鼠标位置</h3>
  <ul>
    <li>通过调用<code>pyautogui.position()</code>函数，可以确定鼠标当前的位置</li>
  </ul>
  <h2 id="控制鼠标交互">控制鼠标交互</h2>
  <h3 id="点击鼠标">点击鼠标</h3>
  <ul>
    <li>鼠标点击<code>pyautogui.click()</code></li>
  </ul>
  <pre><code class="language-python"><div>pyautogui.click(x,y,botton=<span class="hljs-string">'left'</span>)
pyautogui.click(x,y,botton=<span class="hljs-string">'middle'</span>)
pyautogui.click(x,y,botton=<span class="hljs-string">'right'</span>)
</div></code></pre>
  <ul>
    <li><code>pyautogui.mouseDown()</code>按下鼠标按键，不松开</li>
    <li><code>pyautogui.mouseUp()</code>松开鼠标按键</li>
    <li><code>pyautogui.doubleClick()</code>函数只执行双击鼠标左键。</li>
    <li><code>pyautogui.rightClick()</code>和<code>pyautogui.middleClick()</code>函数将分别执行双击右键和双击中键</li>
  </ul>
  <h3 id="拖动鼠标">拖动鼠标</h3>
  <ul>
    <li><code>pyautogui.dragTo()</code>和<code>pyautogui.dragRel()</code>（移动到新的位置或者相对当前位置的位置）</li>
    <li><code>x</code>坐标/水平移动，<code>y</code>坐标/垂直移动，以及可选的时间间隔</li>
  </ul>
  <h3 id="滚动鼠标">滚动鼠标</h3>
  <ul>
    <li><code>scroll()</code>滚动发生在鼠标的当前位置。传递正整数表示向上滚动，传递负整数表示向下滚动。</li>
  </ul>
  <h2 id="处理屏幕">处理屏幕</h2>
  <ul>
    <li><code>pyautogui</code>拥有屏幕快照的功能，可以根据当前屏幕的内容创建图形文件。这些函数也可以返回一个<code>Pillow</code>的<code>Image</code>对象，包含当前屏幕的内容
    </li>
  </ul>
  <h3 id="获取屏幕快照">获取屏幕快照</h3>
  <pre><code class="language-python"><div><span class="hljs-keyword">import</span> pyautogui
<span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image
im = pyautogui.screenshot()
</div></code></pre>
  <h3 id="分析屏幕快照">分析屏幕快照</h3>
  <ul>
    <li>
      如果屏幕上指定的<code>x、y</code>坐标处的像素与指定的颜色匹配，<code>PyAutoGUI</code>的<code>pixelMatchesColor()</code>函数将返回<code>True</code>
    </li>
  </ul>
  <h2 id="控制键盘">控制键盘</h2>
  <h3 id="通过键盘发送一个字符串">通过键盘发送一个字符串</h3>
  <ul>
    <li><code>pyautogui.typewrite()</code>函数向计算机发送虚拟按键</li>
  </ul>
  <pre><code class="language-python"><div>pyautogui.typewrite（<span class="hljs-string">'Helloworld!'</span>,<span class="hljs-number">0.25</span>）
</div></code></pre>
  <h3 id="键名">键名</h3>
  <ul>
    <li><code>pyautogui.KEYBOARD_KEYS</code></li>
  </ul>
  <pre><code class="language-python"><div>pyautogui.typewrite([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'left'</span>, <span class="hljs-string">'left'</span>, <span class="hljs-string">'X'</span>, <span class="hljs-string">'Y'</span>])
</div></code></pre>
  <h3 id="按下和释放键盘">按下和释放键盘</h3>
  <ul>
    <li>
      就像<code>mouseDown()和mouseUp()</code>函数一样，<code>pyautogui.keyDown()和pyautogui.keyUp()</code>将向计算发送虚拟的按键和释放。同样也有<code>pyautogui.press()</code>函数调用上述两个函数，模拟完整的击键
    </li>
  </ul>
  <pre><code class="language-python"><div>pyautogui.keyDown(<span class="hljs-string">'shift'</span>); pyautogui.press(<span class="hljs-string">'4'</span>); pyautogui.keyUp(<span class="hljs-string">'shift'</span>)
</div></code></pre>
  <h3 id="热键组合">热键组合</h3>
  <pre><code class="language-python"><div>pyautogui.keyDown(<span class="hljs-string">'ctrl'</span>)
pyautogui.keyDown(<span class="hljs-string">'c'</span>)
pyautogui.keyUp(<span class="hljs-string">'c'</span>)
pyautogui.keyUp(<span class="hljs-string">'ctrl'</span>)
</div></code></pre>
  <ul>
    <li>上述操作复杂，可以使用<code>pyautogui.hotkey(</code>)`函数,它接受多个键字符串参数，按顺序按下，再按相反的顺序释放</li>
  </ul>
  <pre><code class="language-python"><div>pyautogui.hotkey(<span class="hljs-string">'ctrl'</span>, <span class="hljs-string">'c'</span>)
</div></code></pre>

</body>

</html>