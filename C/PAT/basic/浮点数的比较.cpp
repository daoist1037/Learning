#include<cstdio>
#include<cmath>

const double Pi = acos(-1.0) ;
const double  eps = 1e-8 ;

#define Equ(a, b) ( ( fabs((a)-(b)) ) < (eps) )
#define More(a, b)

/**
 * 当一个变量经过误差较大的运算后，精度的损失就不可忽视
 * 由于精度问题，在经过大量运算之后，可能一个变量中存储等待0是个很小的负数，如果对其开根号sqrt，就会因为不在定义域而报错，这种情况需要eps使变量保证在定义域内
 * 在某些由编译环境产生的原因下，本应为0.00的变量在输出时会变成-0.00.这个问题是编译环境本身的bug，只能把结果存放在字符串中，然后与-0.00进行比较，如果对比成功，则再加上eps来修正0.00
 */